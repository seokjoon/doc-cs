## 1장 파운데이션 모델을 활용한 AI 애플리케이션 입문
  * 모델들을 기반으로 앱을 만드는 AI 엔지니어링

### 1.1 AI 엔지니어링의 부상
* 1.1.1 언어 모델에서 대규모 언어 모델로
* 1.1.2 대규모 언어 모델에서 파운데이션 모델로
* 1.1.3 파운데이션 모델에서 AI 엔지니어링으로


### 1.2 파운데이션 모델 활용 사례
* 1.2.1 코딩
* 1.2.2 이미지 및 동영상 제작
* 1.2.3 글쓰기
* 1.2.4 교육
* 1.2.5 대화형 봇
* 1.2.6 정보 집계
* 1.2.7 데이터 체계화
* 1.2.8 워크플로 자동화


### 1.3 AI 애플리케이션 기획
* 1.3.1 활용 사례 평가
* 1.3.2 기대치 설정
* 1.3.3 마일스톤 계획
* 1.3.4 유지보수


### 1.4 AI 엔지니어링 스택
* 1.4.1 AI의 세 가지 계층
* 1.4.2 AI 엔지니어링 대 ML 엔지니어링
* 1.4.3 AI 엔지니어링 대 풀스택 엔지니어링


### 1.5 마치며


## 2장 파운데이션 모델 이해하기

### 2.1 학습 데이터
* 2.1.1 다국어 모델
* 2.1.2 도메인 특화 모델


### 2.2 모델링
* 2.2.1 모델 아키텍처
* 2.2.2 모델 크기


### 2.3 사후 학습
* 2.3.1 지도 파인튜닝
* 2.3.2 선호도 파인튜닝


### 2.4 샘플링
* 2.4.1 샘플링의 기초
* 2.4.2 샘플링 전략
* 2.4.3 테스트 시점 연산
* 2.4.4 구조화된 출력
* 2.4.5 AI의 확률적 특성
### 2.5 마치며


## 3장 평가 방법론

### 3.1 파운데이션 모델 평가의 어려움


### 3.2 언어 모델링 지표 이해하기
* 3.2.1 엔트로피
* 3.2.2 교차 엔트로피
* 3.2.3 문자당 비트와 바이트당 비트
* 3.2.4 퍼플렉시티
* 3.2.5 퍼플렉시티 해석과 활용 사례


### 3.3 정확한 평가
* 3.3.1 기능적 정확성
* 3.3.2 참조 데이터 유사도 측정
* 3.3.3 임베딩 소개


### 3.4 AI 평가자
* 3.4.1 AI 평가자를 쓰는 이유
* 3.4.2 AI 평가자 사용법
* 3.4.3 AI 평가자의 한계
* 3.4.4 평가자로 활용 가능한 모델


### 3.5 비교 평가를 통해 모델 순위 정하기
* 3.5.1 비교 평가의 과제들
* 3.5.2 비교 평가의 미래


### 3.6 마치며


## 4장 AI 시스템 평가하기

### 4.1 평가 기준
* 4.1.1 도메인 특화 능력
* 4.1.2 생성 능력
* 4.1.3 지시 수행 능력
* 4.1.4 비용과 지연 시간


### 4.2 모델 선택
* 4.2.1 모델 선택 과정
* 4.2.2 모델 자체 개발 대 상용 모델 구매
* 4.2.3 공개 벤치마크 탐색하기


### 4.3 평가 파이프라인 설계하기
* 4.3.1 1단계: 시스템의 모든 구성 요소 평가하기
* 4.3.2 2단계: 평가 가이드라인 만들기
* 4.3.3 3단계: 평가 방법과 데이터 정의하기


### 4.4 마치며


## 5장 프롬프트 엔지니어링

### 5.1 프롬프트 소개
* 5.1.1 인컨텍스트 학습: 제로샷과 퓨샷
* 5.1.2 시스템 프롬프트와 사용자 프롬프트
* 5.1.3 컨텍스트 길이와 컨텍스트 효율성


### 5.2 프롬프트 엔지니어링 모범 사례
* 5.2.1 명확하고 명시적인 지시 작성하기
* 5.2.2 충분한 컨텍스트 제공하기
* 5.2.3 복잡한 작업을 단순한 하위 작업으로 나누기
* 5.2.4 모델에게 생각할 시간 주기
* 5.2.5 프롬프트 반복하며 개선하기
* 5.2.6 프롬프트 엔지니어링 도구 평가하기
* 5.2.7 프롬프트 정리 및 버전 관리하기


### 5.3 방어적 프롬프트 엔지니어링
* 5.3.1 독점 프롬프트와 역 프롬프트 엔지니어링
* 5.3.2 탈옥과 프롬프트 주입
* 5.3.3 정보 추출
* 5.3.4 프롬프트 공격에 대한 방어


### 5.4 마치며


## 6장 RAG와 에이전트

### 6.1 RAG
* 6.1.1 RAG 아키텍처
* 6.1.2 검색 알고리즘
* 6.1.3 검색 최적화
* 6.1.4 텍스트를 넘어선 RAG


### 6.2 에이전트
* 6.2.1 에이전트 개요
* 6.2.2 도구
* 6.2.3 계획 수립
* 6.2.4 에이전트 실패 유형과 평가


### 6.3 메모리


### 6.4 마치며


## 7장 파인튜닝

### 7.1 파인튜닝 개요


### 7.2 파인튜닝이 필요한 경우
* 7.2.1 파인튜닝을 해야 하는 이유
* 7.2.2 파인튜닝을 하지 말아야 하는 이유
* 7.2.3 파인튜닝과 RAG


### 7.3 메모리 병목 현상
* 7.3.1 역전파와 학습 가능한 파라미터
* 7.3.2 메모리 계산
* 7.3.3 수치 표현 방식
* 7.3.4 양자화


### 7.4 파인튜닝 기법
* 7.4.1 파라미터 효율적 파인튜닝
* 7.4.2 모델 병합과 다중 작업 파인튜닝
* 7.4.3 파인튜닝 전술


### 7.5 마치며


# 8장 데이터셋 엔지니어링

### 8.1 데이터 큐레이션
* 8.1.1 데이터 품질
* 8.1.2 데이터 커버리지
* 8.1.3 데이터 양
* 8.1.4 데이터 수집과 주석


### 8.2 데이터 증강 및 합성
* 8.2.1 데이터 합성을 하는 이유
* 8.2.2 전통적인 데이터 생성 기법
* 8.2.3 AI 기반 데이터 합성
* 8.2.4 모델 증류


### 8.3 데이터 처리
* 8.3.1 데이터 검사
* 8.3.2 데이터 중복 제거
* 8.3.3 데이터 정리 및 필터링
* 8.3.4 데이터 형식 맞추기


### 8.4 마치며


# 9장 추론 최적화

### 9.1 추론 최적화 이해하기
* 9.1.1 추론 개요
* 9.1.2 추론 성능 지표
* 9.1.3 AI 가속기


### 9.2 추론 최적화
* 9.2.1 모델 최적화
* 9.2.2 추론 서비스 최적화


### 9.3 마치며


# 10장 AI 엔지니어링 아키텍처와 사용자 피드백


### 10.1 AI 엔지니어링 아키텍처
* 10.1.1 1단계: 컨텍스트 보강
* 10.1.2 2단계: 가드레일 도입하기
* 10.1.3 3단계: 모델 라우터와 게이트웨이 추가
* 10.1.4 4단계: 캐시로 지연 시간 줄이기
* 10.1.5 5단계: 에이전트 패턴 추가
* 10.1.6 모니터링과 관찰 가능성
* 10.1.7 AI 파이프라인 오케스트레이션


### 10.2 사용자 피드백
* 10.2.1 대화형 피드백 추출
* 10.2.2 피드백 설계
* 10.2.3 피드백의 한계


### 10.3 마치며
