# 제0장 속성 - 온라인 게임 프로그래밍

## 0.1 온라인 게임 프로그래밍을 위한 - 네트워크 프로그래밍의 기초
* 네트워크 프로그래밍은 필수(!)
* 네트워크 프로그래밍, 인터넷 프로그래밍
* 인터넷 프로그래밍의 역사와 사상
* OSI 참조 모델
    * 온라인 게임 시스템과 레이어
    * 레이어4는 대부분의 경우 TCP를 사용하고, 레이어3 이하는 직접적인 조정이 필요 없음
    * 레이어5 이상은 게임단에서 구현한다
* 소켓 API의 기초 지식
* 온라인 게임과 소켓 API
    * 커넥션 지향(스트림형), 커넥션리스 지향(데이터그램형)

## 0.2 소켓 프로그래밍 입문 - 복수의 동시 접속을 처리, 성능을 추구한다
* 통신로의 특정
* 소켓 API의 기본
* TCP 통신로의 상태 전이와 소켓 API
* 복수의 동시 접속을 처리한다
* 동기적 호출(블로킹)과 스레드
    * 스레드 방식의 처리 부하 문제
* 싱글 스레드, 논블록킹, 이벤트 구동
* 온라인 게임에서의 입출력 구현의 특징
* 온라인 게임과 구현 언어
* 성능의 최대화 ＆ 개발 효율 향상
    * 온라인 게임 고유의 특성에 의한 언어별 성능 차이
* 멀티코어 서버의 성능을 끌어낸다
    * 컨텍스트 스위치 - CPU의 설정 상태를 일시적으로 보관해 둔다
    * 멀티코어 머신이며 서버 프로세스 수를 너무 늘리지만 않으면 OK
* 멀티코어 머신과 네트워크의 스루풋
    * 이더넷 프레임
    * 네트워크 계층별 헤더
    * 멀티코어 머신의 송신 능력
* 서버 구현의 간소화
    * libevent의 특징

## 0.3 RPC 공략 - 최소 기능의 통신 미들웨어
* 통신 라이브러리의 필요성
* 포맷을 결정하고 송수신한다
* 온라인 게임에서 사용하는 RPC의 전체적인 모습
    * RPC 스터브 코드를 자동 생성하는 RPC 툴
    * 온라인 게임과 바이너리 데이터 교환 포맷/라이브러리
* 보충 - UDP의 이용

## 0.4 게임 프로그래밍의 기초
* 게임 프로그래밍의 역사
* 「점만 찍을 수 있다면 게임은 만들 수 있다」 인베이더 게임
* 가상의 코드로 알 수 있다! 게임 프로그램의 기본 해부
    * 초기화
    * 무한 루프
    * 각 스프라이트의 동작 - 게임 로직의 본체
    * 화면 표시
    * 서브루틴
* 게임 프로그래밍의 비결
* 두 가지 프로그래밍 기법의 유사성


# 제1장 온라인 게임의 역사와 진화

## 1.1 온라인 게임의 기술사
* 온라인 게임의 역사는 아직 50년
* 1950년 이전 : 계산기의 등장
* 1950년대: 초기 비디오 게임
* 1960년대 : 영향력을 가진 각종 머신의 등장
* 1970년대: 온라인 게임 기본 요소가 갖추어짐
* 1980년대: 네트워크 대전 게임의 등장
* 1990년대: 게임 시장의 확대
* 2000년대 전반 : 온라인 게임의 상업적 성립
* 2000년대 후반: 웹 브라우저 기반 MMOG의 상업적 성공
* 2010년대 이후 : 과연 어떤 일이 일어날 것인가?

## 1.2 기술의 변천에서 알 수 있는 - 게임 문화/경제권
* 기술의 변천도를 읽자
* 3개의 영역(카테고리)
    * 해커 문화권
    * 콘솔/아케이드 게임 비즈니스권
    * 마이크로소프트권
    * 두 가지의 게임 경제/문화권
* 문화, 경제, 기술의 관계

## 1.3 요약


# 제2장 온라인 게임이란 무엇인가?

## 2.1 「온라인 게임」이라는 용어의 정의
* 온라인 게임의 4개의 측면

## 2.2 온라인 게임의 물리적 측면
* 물리적 구성요소
    * 컴퓨터 네트워크
* 물리 모델/ 물리적인 네트워크 구성
    * 이 책이 대상으로 하는 회선은 「인터넷」 기반

## 2.3 온라인 게임의 개념적인 측면
* 온라인 게임과 기본구조
    * 게임 플레이의 기본 - 「인지」, 「판단」, 「조작」의 반복
    * 비디오 게임의 구조
* 게임 플레이 공간
* 게임의 진행
* 하나의 게임의 진행을 공유한다
    * 공유가 「가능하다」

## 2.4 온라인 게임의 비즈니스적 측면
* 비즈니스적 관점의 요구
* 테스트 플레이어를 효과적으로 모으고 싶다
    * 클로즈 베타 테스트(CBT)
    * 오픈 베타 테스트(OBT)
* 자주 갱신하고 싶다
    * (1) 정기적 패치
    * (2) 대규모 패치(확장 디스크, 추가 패키지)
    * (3) 긴급 메인터넌스
* 머신의 대수와 회선 대역을 절약하고 싶다
    * (1) 인건비＆ (2) 설비 코스트 - 운영, 개발 후에 소요되는 코스트가 큼
    * 머신 코스트의 견적 - 서버가 고장 날 확률을 포함해 둔다
    * 회선 코스트의 견적 - 대역은 가능한 절약한다
* 작게 시작하고 싶다. 스케일러빌러티를 지니게 하고 싶다
* 다양한 과금 옵션을 제공하고 싶다
    * 게임 포인트의 등장 - 과금의 세분화, 리얼타임화의 실현
* 공격자를 저렴한 비용으로, 빨리, 확실히 배제하고 싶다
    * 상업적 의도의 어뷰즈
    * 상업적 의도가 없는 어뷰즈 - 여러 가지의 공격, 3D 온라인 게임 전용 게임 클라이언트
* 서비스 정지 시간과 횟수를 줄이고 싶다
    * (1) 계획적인 메인터넌스로 인한 정지
    * (2) 결함이나 공격에 의한 서비스 정지
* 게임 플레이 결과를 피드백하고 싶다
    * 게임 플레이의 메타 정보
    * (1) 하이스코어 랭킹
    * (2) 플레이 실적
    * (3) 그 외의 통계
    * 한층 더 고도의 기술이 요구되는 플레이 실적
* 더욱 간단하게 다른 플레이어와 만날 수 있게 하고 싶다
    * (1) 자동 선택식
    * (2) 전용 로비
    * (3) 가상 세계(비쥬얼 로비, 버추얼 로비)
    * 전용 로비 형식과 가상 세계의 차이점
    * 플레이어 매칭의 향후

## 2.5 온라인 게임의 사람과 조직적 측면
* 온라인 게임 서비스의 운영에 관한 사람들
    * 세 가지 기능과 분담 패턴
* 온라인 게임 서비스 운영의 3가지 전문 기능
    * 만드는 사람들
    * 반드시 필요한 4가지 직종
    * 소규모 팀
    * 대규모 팀
    * 직종의 밸런스에서 엿볼 수 있는 게임 개발의 특유한 점 - 데이터 작성 스텝의 비율
* 운용하는 사람들
    * 서버 설비

## 2.6 온라인 게임 프로그래머에 요구되는 지식군
* 온라인 게임 프로그래머에 필요한 능력과 경험
    * 프로그래밍 기초 스킬
    * 게임 프로그래밍의 기초 지식(온라인 게임 개발에서도 필요)
    * 게임 클라이언트 개발 지식
    * DB 지식
    * 시스템 운용 지식S
* 여러 방면에서 필요한 온라인 게임의 개발 지식

## 2.7 온라인 게임을 뒷받침하는 기술의 대구분
* 온라인 게임을 뒷받침하는 기술의 4가지 형식
    * C/S형과 P2P형 - 물리적인 구조의 두 가지 전형적 패턴
    * MMO형과 MO형 - 논리적인 구조의 두 가지 전형적 패턴
    * 온라인 게임의 4가지 형식 - 물리적 구조×논리적 구조

## 2.8 개발 코스트를 좌우하는 기술적 포인트
* 온라인 게임과 개발 기법의 현재
* 온라인 게임의 게임 본체를 뒷받침하는 3가지 축
    * 게임 데이터 형식
    * 게임 통신 형식
    * 게임 반응속도

## 2.9 요약


# 제3장 _ 온라인 게임의 아키텍처

## 3.1 게임 프로그램의 특성 - 좋은 리스폰스를 계속해서 유지한다
* 리스폰스의 중요성
* 온 메모리가 필요한 이유
* (1) 16밀리초마다 변화
    * 게임 진행을 표현하는 데 필요한 정보와 그 사이즈
    * RDBMS를 이용해 구현할 수 있을까? - 온 메모리와의 비교
* (2) 대량의 오브젝트 표시
    * 패밀리컴퓨터와 CPU 사이클
    * 플레이스테이션 3(PS3)과 CPU 사이클 - RDBMS 방식으로 개발할 수 있을까?
* (3) 플레이어의 조작을 예상할 수 없다
    * RDBMS 방식으로는 실현할 수 없는 정보량, 처리 속도
* CPU와 동일 머신에 게임 진행 데이터를 배치해야 한다
## 3.2 온라인 게임 특유의 요소
* 통신 레이턴시
    * 통신 시간의 내역
    * 피할 수 없는 지연 - 지연과 게임 장르
* 대역
* 서버 머신
* 보안
    * 치트 - 최대의 보안 이슈
    * 치트는 왜 행해지는가?
    * 치트 행위의 수단
    * 치트의 조작 대상
    * 노이먼형 컴퓨터의 숙명 - 치트 행위에 대한 방지 서비스
    * 무서운 치트 행위의 파급 효과
* 보조 시스템(주변 시스템)

## 3.3 물리 아키텍처의 상세 해부 C/S형, P2P형
* 기본적 네트워크 토폴로지
    * 실제로 사용되는 것은 스타와 버스, 풀 메시 - 통신 레이턴시의 최소화
* 물리 아키텍처의 종류
* C/S형
    * 리플렉터형
* P2P형
    * NAT 트래버설
* C/S＋P2P 혼합형
* ad-hoc 모드

## 3.4 논리 아키텍처의 상세 해부 MO형
* MO, MMO란?
    * MMO와 MO의 하이브리드(혼합)
* MO형, MOG
* 동기식
* 동기식/풀 메시형의 구현
    * 각 단말(플레이어)이 송수신하는 정보의 내용
    * 동기식/풀 메시형에 필요한 조건과 메리트
    * 동기식/풀 메시형의 3가지 문제점 - 통신망과 송수신의 완전성의 취약점, 게임의 중도 참가
    * 통신로의 신뢰성
    * 「가장 느린 단말의 속도에 맞춰진다」는 문제
* 동기식/스타형
    * 스타형이 가지고 있는 4가지 문제
    * 동기식 전반의 큰 문제 - 게임 도중에 참가할 수 없다
    * 동기식의 메리트와 문제 해결 방법
* 비동기식
* 비동기식의 구현 방침의 세우는 방법 - 게임 내용의 상세한 분석이 필수
* 3가지 기본 요소 「자신」, 「상대」, 「환경」
    * 3가지 요소의 관계
* (1) 자신과 상대
    * 격투 게임의 예
    * 공격, 방어, 타격 판정
    * 격투 게임의 시퀀스 그림
    * 추상도가 낮은, 원인을 알 수 있는 데이터를 송신할 필요가 있다 - 결과의 납득
    * 결과가 어긋나는 문제 발생!
* 결과의 정합성을 유지하는 방법
    * 데미지를 발생시킨 쪽의 결과를 사용한다
    * 데미지를 받은 쪽의 결과를 사용한다
    * 방식 선택의 원칙 - 플레이어의 만족감 향상을 위해
* (2) 자신과 환경
    * 배타 제어가 필요한 타입의 환경 요소 - 경합하는 자원 「폭탄」
    * 배타 제어가 필요 없는 타입의 환경 요소 - 줄지 않는 자원 「물」
    * 게임의 환경 요소는 의외로 다루기 어렵다 - 일단 게임 내용을 상세하게 이해한다
* 배타 제어의 구현
    * 아이템 듀프 문제
    * 아이템에 고유한 ID를 부여한다 - 듀프가 일어났는지를 판정, 발생하는 문제
    * 아이템 듀프의 대책 - 중재 역할의 소프트웨어를 배치한다.
    * 중재역의 기본 기능과 사용법
    * 폭탄 이외의 환경 요소의 경우
* 자동적으로 상태가 변화하는 환경
    * 동적인 환경에서 일어나는 문제 - 완전하게 병행 관리하는 방법으로는 어렵다
* 동적 환경에서 일어나는 문제의 대처법 선택
    * (1) 상대와 환경의 관계

## 3.5 논리 아키텍처 상세 해부 MMO형
* MMO형, MMOG
    * 영속적이란? - 게임 플레이 소요 시간과 축적성
    * 영속적인 데이터, 대량으로 축적되는 데이터의 일관성 유지의 어려움
    * 클라이언트와 서버의 완전 분리
* MMOG의 구조
    * MMO형의 구현 방침 - 브라우저식, 순수한 C/S모델
    * 브라우저식과 동기식 및 비동기식의 차이
    * MMO형에 있어서 서버, 클라이언트의 기능
    * 서버의 처리 - 서버 측의 게임은 계속 진행된다.
* MMO형만의 과제

## 3.6 정리


# 제4장 실전 - C/S MMO 게임 개발

## 4.1 온라인 게임 개발의 기본적인 흐름
* 프로젝트 자료/성과물
    * 준비와 초기 구현은 동시에 병행한다
* 개발의 진행과 자료 준비의 순서
* 기술자의 자료/성과물

## 4.2 C/S MMO 게임의 경향과 대책
* C/S MMO 게임의 특징
* C/S MMO형(MMO형) 게임의 특성
    * C/S MMO형의 제약

## 4.3 기획 자료와 5개의 설계 자료 - 가공의 게임 「K Online」의 개발에서 배운다
* 샘플 게임의 소재 찾기
* 기획 상세 자료
    * 기획 상세 자료의 필요성
* MMOG의 방대한 게임 설정
    * 5가지 설계 자료
* 설계상의 중요한 판단

## 4.4 1 -시스템 기본 구조도의 작성
* 시스템 기본 구조도의 기본
* 확장성을 가진 서버 시스템이 필요
    * 다양한 보틀넥 - 스케일업 방식의 선택에 대해서
* 게임 서버/DB의 보틀넥을 해소한다
* 아무것도 고려하지 않는 경우
* 공간 분할법
    * 공간 카피
* 인스턴스법
* 패러렐 월드 방식
    * 가장 보틀넥이 되기 쉬운 것은 DB의 쓰기 처리
    * 패러렐 월드 방식의 DB 분할
    * 패러렐 월드 방식의 문제
* 복수의 방법을 병용
* 각 방식의 도입 난이도
* 각 월드의 DB(게임 DB) 서버의 절대 성능 향상
    * 애플리케이션단의 개선점 연구
* K Online의 설계 사이징
    * 보틀넥의 확인
    * 설계 사이징에 대한 판단 원칙
* 게임 로직의 처리 부하로부터 사이징
* 게임 DB의 처리 부하로부터 사이징
* 규모에 대한 최소한의 검토 결과, 보다 나은 유저 체험을 위하여…
* 서버의 기본 구조, 1 -시스템 기본 구조도의 작성

## 4.5 2 -프로세스 관계도 작성
* 2 - 프로세스 관계도 준비
* 서버 접속 구성
* 서버의 접속 구성
* 패러렐 월드 방식을 사용하여 확장하는 경우

## 4.6 3 - 대역/머신 리소스 계산 자료의 작성
* 프로세스 리스트를 토대로 머신 리소스를 사이징
* CPU 센트릭(중심적, 의존적) 머신, 스토리지 센트릭 머신
* 머신 리소스의 코스트 견적
    * 머신 리소스 유지 코스트
* 대역 코스트의 견적
    * 트래픽의 98%가 플레이어/NPC의 이동 통지이다
* 대역 반감을 위한 지침
    * 기획의 조정 - 대역 삭감 작전 1 -
    * 프로그램을 연구 - 대역 삭감 작전 2 -
* 대역 삭감에는 기획 내용의 재검토가 효과적

## 4.7 4 - 프로토콜 정의 자료의 작성 프로토콜의 기본적인 성질
* 4 - 프로토콜 정의 자료의 기본
* 「프로토콜의 기본적인 성질」의 핵심요소
    * 프로세스 관계도 등장요소
        * 클라이언트, 게임서버, 로그인서버, 메시지서버, DB서버, 리버스프록시서버, 월드서버, 전체공통서버, 과금인증서버, 로그서버, DBMS, 결제회사서버
* 프로토콜의 종류와 프로세스 관계의 종류
* 8 종류의 프로토콜
* C/S MMO에서는 TCP를 이용한다
* 「프로토콜의 기본적인 성질」과 그 대응 일람표
    * 프로토콜 설계의 기본 전략

## 4.8 프로토콜 정의 자료 프로토콜의 API 사양(개관)
* 프로토콜 구현의 원칙
    * 백엔드에 기본/범용 기능을, 프론트엔드에 전용 기능을 구현한다
    * 백엔드에 프론트엔드가 의존하는 구조
    * 프로토콜은 스테이트리스＆단순한 기능으로 한다
    * 외부로부터 오는 예외적 현상은 한 곳에 집중시킨다
    * 우수한 API의 호출 시퀀스 - 호출하지 않는 것이 우수!?
* 8가지 프로토콜의 기능/형태 개요
    * gmsv 프로토콜
    * loginsv 프로토콜
    * msgsv 프로토콜
    * dbsv 프로토콜
    * worldsv 프로토콜
    * commondbsv 프로토콜
    * authsv 프로토콜
    * logsv 프로토콜

## * 4.9 4 - 프로토콜 정의 자료 프로토콜의 API 사양(상세)
* 프로토콜의 API 사양(상세) 작업
* API의 함수 정의
    * gmsv 프로토콜
    * API 타입과 메시지의 특성
    * loginsv 프로토콜
    * msgsv 프로토콜
    * dbsv 프로토콜
    * worldsv 프로토콜
    * commondbsv 프로토콜
    * authsv 프로토콜
    * logsv 프로토콜
* 정수 정의
* API의 호출 시퀀스
    * 필요한 시퀀스도 - 복수의 프로세스가 관계하는 일반적인 처리란 무엇인가?
    * (1) 인증
    * (2) gmsv의 캐릭터 작성
    * (3) gmsv, msgsv에 로그인
    * (4) gmsv로부터 로그아웃
    * (5) gmsv의 캐릭터 이동
    * (6) gmsv의 캐릭터 인벤토리 조작(숍, 트레이드)
    * (7) msgsv의 친구 목록에 친구를 추가, 삭제
    * (8) 온라인 친구에게 메시지를 송신한다.
* 시퀀스도의 작성 포인트

## 4.10 4 - 프로토콜 정의 자료 패킷의 포맷
* C/S MMO에서는 주로 TCP를 이용한다
* C/S MMO는 전용 바이트 배열을 가지는
* 바이너리 프로토콜을 사용한다
* 바이너리 프로토콜의 구현
    * 레코드의 크기
    * 헤더
    * 데이터 부분의 압축과 암호화
    * 구현상의 요령

## 4.11 DB 설계도
* 중요한 테이블의 설계는 프로그래밍을 시작하기 전에
* C/S MMO에서의 DB 구현의 역사적 변천
    * 70~80년대：데이터의 영속화 없음. 부활의 주문
    * 90년대：파일로 저장
    * 2000년대 전반~：RDBMS
* K Online에 필요한 테이블 추려내기
    * 영속화가 필요한 정보와 데이터의 포함 관계
    * 데이터의 특성과 개별 테이블의 준비
* DB의 성능 예측
    * DB의 처리 성능과 사이즈
    * 테이블의 특성, 주의해야 할 테이블
    * 발행하는 쿼리의 내용 - read편
    * 발행하는 쿼리의 내용 - write편

## 4.12 서버/클라이언트 소프트웨어＋미들웨어 실전에 빠뜨릴 수 없는 개발 기반
* 온라인 게임의 미들웨어
    * C/S MMO용의 미들웨어
    * 풀 장비형 미들웨어
    * 소규모형 MMOG 미들웨어
    * 통신 미들웨어만을 이용
* 개발 기반 소프트웨어 즉시 시험해 볼 수 있는 C/S MMO 개발 체험
    * 서버 관련 소프트웨어
    * 클라이언트 관련 소프트웨어

## 4.13 프로그램을 작성할 때 기본 원칙
* 프로그래밍을 시작하는 방법, 이어가는 방법
* 데이터 구조 우선의 원칙
    * 비디오 게임에서의 데이터 분류
* 데이터 구조를 구현하기 전의 검토
    * 적 캐릭터와 팝 설정
* 플레이 가능 상태 유지의 원칙
* 백엔드는 나중에 만든다는 원칙
* 계속적 측정의 원칙
    * 클라이언트 개발에서의 계속적 측정의 예
    * 서버 개발에서의 계속적 측정

## 4.14 C/S MMO 게임 「K Online」의 구현 프로그래밍 작업 스타트!
* 개발의 순서
* K Onilne의 분담 계획
* K Online에서의 「스켈레톤」과 「프로토타입」 단계 나누기
* ［스텝 1~2］스켈레톤~프로토타입 단계
    * 스켈레톤 코드의 준비
    * 1 - autocli
    * 2 - cli
    * 3 - 프로토콜
    * 4 - ID
    * 5 - gmsv
    * 6 - dbsv
* 「작동해 보지 않으면 알 수 없다!」
    * 게임 개발의 난항 - 기업에 의한 온라인 게임 개발
* 스켈레톤의 전체 모습
    * cli의 내용
    * gmsb, dbsv, proto의 내용
    * 어떤 순서로 무엇을 작성할 것인가
* 먼저 프로토콜 정의 파일 k.xml를 작성한다
* 프로토콜 정의 포인트
* 통신 소통 확인：ping 함수
* 어카운트 등록＆어카운트 인증：
* 캐릭터 작성：createCharacter 함수
* 로그인：login 함수
* 지상 이동：move함수, moveNotify
    * 매스 단위
    * 경로 탐색과 실제 이동 처리
    * 이동 경로를 송신하는 방법 - 최종 결과를 우선하여 송신한다
    * 이동 결과의 통지 범위
    * moveNotify 함수
    * attack 함수, attackNotify 함수
* gmsv/Makefile를 작성한다
* gmsv/climain.cpp와 gmsvmain.cpp를 샘플에서 카피
    * sv.cpp에 signup 함수를 구현
    * 「dbsv 1회 왕복」형의 요구와 스레드
* 자동 테스트 클라이언트 autocli의 구현
    * 테스트 상태 변화
    * autocli의 main() 함수
    * signup() 함수
* 그래피컬 클라이언트 cli의 작성과 동작 확인
    * SDL
    * 그림을 그린다
    * 동작 확인
    * 폰트 처리의 구현
    * 적을 등장시킨다, 적을 뒤쫓는다
    * 적을 쓰러뜨린다, 경험치가 쌓인다
    * 다음에도 플레이 가능하게 한다 - 플레이 상태의 저장
* 스켈레톤 이후의 개발

## 4.15 정리


# 제5장 실전 - P2P MO 게임 개발

## 5.1 P2P MO 게임의 경향과 대책
* P2P MO와 액션 게임 - 게임 상태가 높은 빈도로 변화한다
* RPC형의 구현과 공유 메모리형의 구현
* P2P MO 게임의 특징
* P2P MO 게임의 이점
* 기획 초기부터 「멀티 플레이」를 의식한다.

## 5.2 가공의 게임 「J Multiplayer」의 개발에서 배운다
* J Multiplayer - K Online과 비교
* P2P MO 게임 개발의 기본적 흐름
* P2P MO 게임 개발의 성과물 - 개발의 단계와 각종 자료
    * 기획 상세 자료
* C/S MMO와의 데이터량/규모의 차이

## 5.3 P2P MO 게임의 설계 자료
* 시스템 기본 구조도
* 프로세스 관계도
    * 스타형인가, 풀 메시형인가
    * 우선은 스타형을 검토한다
    * 게임 도중에 참가하는 구현
* 대역/머신 리소스 계산 자료
* 프로토콜 정의 자료, API 사양
    * 프로토콜의 시퀀스도
    * 함수나 정수의 정의
* 대역 소비량의 사이징
    * 「600분의 1」 - 게임 기획 내용을 정밀 조사하여 해결책을 찾는다.
* 그 외의 자료

## 5.4 서버/클라이언트 소프트웨어＋미들웨어, 기본 원칙
* P2P MO 개발 성과물의 실제의 모습
* P2P MO용 미들웨어
* 프로그램 작성 시의 기본 원칙

## 5.5 P2P MO 게임 「J Multiplayer」의 구현
* J Multiplayer의 작업 분담 계획
* 구현 작업의 흐름 - K Online의 복습
* J Multiplayer의 개발 요령
* 제1단계에 필요한 요소
* 클라이언트 프로그램의 구현 예
* 「공유 메모리형」으로 구현 - 구현 개시
    * 경합상태 - 공유 메모리형에서의 주의점
    * 락(Lock)
    * P2P MO와 경합상태
* P2P MO의 구현에서 어떤 방식으로 경합을 방지하는 것이 좋은지에 대한 판단
    * 동기화 관련 구현 예
    * 가동물 열거와 클래스 설계
    * 기본 동작의 취급을 매트릭스화
    * 게임 진행 상태를 변경하는 조작에 대한 사양 정의
    * PlayerCharacter 처리의 사양 정의
    * Enemy 처리의 사양 정의 Enemy/Create
    * Bullet 처리의 사양 정의
* 공유 메모리를 어떻게 코드화할까
    * RPC형 - C/S MMO의 경우
    * 공유 메모리형 - P2P MO의 경우
    * RPC형의 코딩량 - move(5,5)
    * 공유 메모리형의 코딩량 - move(5,5)
    * 공유 메모리형의 강점, 약점
* ［보충］코드를 간략하게 할 수 있을까?
* SyncValue 클래스

## 5.6 C/S MO 게임을 뒷받침하는 기술 ［보충］
* C/S MO와 NAT 문제
* NAT, NAT 문제란?
* NAT 트래버셜 - 접속 통신로를 확립하는 기술
    * NAT 트래버셜 기술의 한계
    * NAT 트래버셜 기술을 사용하는 경우의 또 다른 단점
* NAT 문제의 현실적 대처
* 릴레이 서버
* 릴레이 서버의 트레이드오프
    * (1) 지연이 커지는 문제
    * (2) 서버 대역 코스트가 발생하는 문제

## 5.7 정리


# 제6장 _ 온라인 게임의 보조 시스템

## 6.1 보조 시스템에 요구되는 각종 기능
* 기존 서비스로 알아보는 보조 시스템의 기능
    * 범용
    * 게임기용
    * 웹 브라우저 베이스 게임 전용
    * 기존 미들웨어
* 기존 서비스의 기능 일람
* Web 베이스 개발 방법과 C/S형의 개발 방법

## 6.2 커뮤니케이션/ 통신 보조 시스템
* 플레이어 매칭
    * P2P MO 게임에서 멀티 플레이가 가능한 조건
    * 매칭 서버
    * 멀티 플레이를 실현하는 두 가지 조건의 구체화─J Multiplayer의 경우
    * 멀티 플레이를 실현하는 두 가지 조건의 실현─J Multiplayer의 경우
    * 매칭 결과 화면
* 로비
    * 로비와 매칭
    * 스타크래프트 II의 예
    * 구현 포인트
* 릴레이 서버
    * 릴레이 서버에 요구되는 성능
* 채팅
    * 자작 채팅의 구현
    * 자작 채팅의 기본 동작
    * 메시지 전달의 규모
* 메일
* 친구 목록
* 프레젠스
    * 게임 서비스의 프레젠스 특징
    * 프레젠스의 구현
* 락 서버
    * 락 서버의 구현
* 블랙 리스트
    * 블랙 리스트의 구현
* 보이스 채팅

## 6.3 게임 클라이언트 구현의 보조 시스템
* 플레이 실적 관리
    * 플레이 실적 관리의 구현에 대해
* 스토리지 기능
* (게임 클라이언트) 업데이트
    * 업데이트의 기본 기능
    * 업데이트와 액세스 패턴
    * 업데이트 기능을 자작하는 방법
* 랭킹
    * 랭킹 기능의 구현─온라인 게임 특유의 요구 사항
* 잠정 랭킹법

## 6.4 운영 보조 시스템
* 뉴스 배포
    * 뉴스 전달 방법

## 6.5 과금 결제 관련 보조 시스템
* 과금 인증
    * 온라인 게임의 과금
    * 결제 처리의 구조
    * 결제 시퀀스
    * 결제 회사를 사용하는 이점
* 버추얼 포인트 관리
    * P2P MO의 경우, C/S MMO의 경우
    * 버추얼 포인트 관리 서버의 구현
    * 버추얼 포인트 관리의 주의점

## 6.6 그 외의 보조 기능
* 게임 데이터 열람/검색 툴
    * 플레이 데이터의 저장 상태
    * 깔끔하지 않은 저장 상태
    * 기계도 인간도 읽을 수 있는 형식으로 해 둔다
    * 키워드 검색을 위한 방법 연구
    * 게임 설정 데이터와 DB
* 워드 필터

## 6.7 정리


## 제7장 _ 온라인 게임 운영을 뒷받침하는 인프라

## 7.1 인프라 구축의 기초지식
* C/S MMO와 P2P MO의 인프라복습 -
* 인프라 구축에 필요한 작업
* 인프라에 소요되는 코스트와 견적
* 코스트의 감각, 단위
* 온라인 게임 서버에서 어느 정도 허용되는 조건
* 하드웨어, 정보 기기
    * 서버 머신
    * 스토리지
    * 네트워크 스위치
    * 라우터/방화벽
* 소프트웨어
    * 서버 OS
    * DBMS
    * 바이러스 스캔 소프트웨어
    * 가상화 소프트
* 데이터 센터 관련
    * 데이터 센터 이용료
    * 데이터 센터 구축 비용
* 서비스(데이터 센터 관련 제외)
    * 서버 감시 서비스
    * 도메인 사용료, 전자서명 서비스료
* 회선 이용료
* 전기세

## 7.2 개발자를 위한 인프라 구축 노하우
* 서비스 스케일의 확대/축소
* 일반적인 환경
    * 사이징이 어려운 조건
* 부하 곡선
    * 최초에 피크가 온다는 전제로 설계한다
    * K Online의 경우
    * J Multiplayer의 경우
* 개발자를 위한 인프라 구축의 포인트
* 서버 디플로이먼트
    * 메인터넌스 시간과 디폴로이먼트의 자동화
* 스테이징
    * 온라인 게임 고유의 주의점
* 서버 모니터링, 생사 감시
* 로그 출력/관리
    * 로그 방침 - 「가능한 모두」, 「원인과 결과 양쪽 모두」
    * 로그 출력 방법 - 추천하는 방법, syslog의 문제점
    * 로그 서버

## 7.3 K Online, J Multiplayer의 인프라 구축
* K Online의 인프라
    * 알파 테스트
    * 클로즈 베타 테스트
    * 오픈 베타 테스트
* J Multiplayer의 인프라
    * 일부 보조 시스템은 자작한다
    * 먼저 부하 검증을 실시하여 인프라를 사이징한다
    * 동시 플레이수, 등록 유저수 - 랭킹의 경우의 일반적인 부하 검증 절차1 -
    * 플레이 스타일을 예측한다 - 랭킹의 경우의 일반적인 부하 검증 절차2 -
    * 부하 검증 결과를 설계에 반영시킨다.

## 7.4 부하 테스트
* 부하 테스트의 준비
* K Online의 상용 환경 부하 테스트
    * K Online의 테스트 시나리오
    * 테스트의 분할
    * 부하 테스트에 필요한 환경
* 부하 테스트에서 사용하는 서버 감시 커맨드
    * vmstat, /proc/interrupts
    * ps
    * top
    * netstat
* J Multiplayer의 상용 환경 부하 테스트
    * J Multiplayer의 테스트 시나리오
    * 부하 테스트에 필요한 환경

## 7.5 운용 개시
* 운용 개시 직전 - 시큐리티 설정의 확인부터
    * 시스템 외부로부터의 공격에 대한 시큐리티
    * 시스템 내부의 관리 수단에 관한 시큐리티
* 운용 개시 직후 - 시스템 감시
* 수십 대의 서버를 그룹화
* 트러블이 발생했을 때의 대응

## 7.6 요약


# 제8장 _ 온라인 게임의 개발 체제

## 8.1 게임의 기획 내용과 개발 팀 온라인 게임 특유의 과제
* 「게임의 기획 내용」이 팀 운영의 열쇠를 쥐고 있다
* 게임 데이터의 영속화 정도
    * 운영 개시 후 3개월이 가장 힘들다. 운영은 5~10년 계속한다
    * 게임의 운영과 기술자
    * 실제의 프로젝트 관리에 있어서의 과제
* 게임에 있어서의 플레이어들 간의 관계
* 플레이 결과의 공유 범위
* 채팅 시스템의 내용
* 메인터넌스와 업데이트의 스케줄
* 소스 코드의 규모
    * 빌드 시간
    * 프로그램의 기동에 걸리는 시간
    * 평가를 위한 스텝 수
    * 서버 프로그램의 기동 절차
    * 데이터의 밸리데이션

## 8.2 온라인 게임 개발 팀의 실제 일반 소프트웨어 개발에도 공통되는 화제
* 작업 분담
* 온라인 게임 프로그래머의 지속적인 스킬 업 방법
    * 무예의 스텝 업 지침 「수,파,리」에서 배운다
    * 「수」의 단계 - 흉내부터 시작할 것
    * 「파」의 단계 - 세미나, 컨퍼런스, 그리고 경계 영역으로 뛰어들 것
    * 「리」의 단계 - 엔지니어의 스텝 업, 그 다음에 놓여 있는 것은...
* 프로젝트 관리방법
* 개발 환경의 선정
* 프로젝트 이관
    * 테스트 준비
    * 개발 환경의 구축 시간은 짧다
    * 정보 시큐리티의 조절

## 8.3 요약 