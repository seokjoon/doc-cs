## 01 엔터티 이야기
* 1.4. 엔터티 분류법
    * 보이는 엔터티, 추상 엔터티
    * 자립(강) 엔터티, 종속(약) 엔터티
* 1.7. 종속 엔터티의 종류
* 1.9. 엔터티 정의 방법
    * 원천 데이터
        * 엔터티 간 참조 무결성 관계 존재
        * 정규화 철저
    * 가공 데이터
        * 주로 업데이트 발생하지 않음
        * 참조 무결성 관계 거의 존재하지 않음
* 1.10. 데이터 본질에 따른 엔터티 분류법
    * 실체: 만질 수 있는 것
    * 행위: 실체에 의해 생긴 원천 데이터, 순서 존재 가능
    * 가공: 원천 데이터가 아닌 데이터 관리
    * 기준(참조)
* 1.15. 엔터티 정의 방법 - 데이터 생성에 따른 분류법
    * 내부, 외부
* 1.16. 엔터티 정의 방법 - 엔터티 유형에 사른 분류법
    * 기본: 실체와 유사
    * 내역: 행위와 유사
    * 상세: 엔터티에 대한 상세정보/하위 엔터티
    * 이력
    * 코드
    * 관계
    * 집계
* 1.17. 교차 엔터티란?
    * 다대다
* 1.18. 엔터티 설계 원칙
    * 데이터 정체성
    * 엔터티 무결성
    * 엔터티 유일성
    * 데이터 혼용 배제
    * 타 엔터티와의 관계 존재
    * 프로세스 도출 지양: 프로세스와 엔터티는 별개
    * 화면 도출 지양
    * 데이터 관리 요건: 관리 필요 없는 데이터는 삭제
* 1.19. 엔터티 명은 어떻게 정하는가?
* 1.20. 다양한 엔터티에 대한 명명법
* 1.21. 엔터티 설명은 어떻게 기술하는가?
* 1.22. 개념 모델에 포함하는 주요 엔터티란?
* 1.23. 엔터티 정의의 또 다른 이름 - 업무 식별자
* 1.24. 업무 식별자 도출 방법
* 1.25. 업무 식별자 표현 방법
* 1.26. 데이터 모델을 검증할 수 있는가?
* 1.27. 엔터티 검증
    * 엔터티 존재 여부
    * 엔터티가 아니라 속성인지
    * 단일 엔터티가 단일 주제로 구성되는지
    * 유사 성격 데이터를 개별 엔터티로 관리하지 말아야
    * 엔터티명은 필요단어로 구체적으로
    * 엔터티명이 주식별자와 한쌍
    * 모든 엔터티에 업무식별자 존재해야
    * 이력데이터 여부
    * 일대일인 두 엔터티의 합체 가능 여부, 주식별자가 동일한 엔터티가 존재하면 안됨
    * 종속 관계 엔터티의 주 식별자 상속이 적절한지
    * 데이터 인스턴스가 하나뿐인 특수 엔터티는 보통 불필요
    * 주식별자 존재해야
    * 엔터티는 쉽게 설명 가능해야
    * 외부/복제 엔터티의 엔터티명과 주식별자가 원천엔터티의 그것과 동일해야
* 1.28. 데이터 모델 설계 원칙
* 1.29. 무결성에 대해서
    * 엔터티 무결성
        * 식별자는 중복되지 않고 null 이 아님
        * 업무식별자는 논리적(uniq index), 주식별자는 물값적으로(pk) 무결성 만족시킴
    * 참조 무결성
        * 외래 식별자 속성 값은 참조되는 엔터티의 주식별자 값과 일치 혹은 널(fk)
    * 도메인 무결성
        * 속성에 대한 무결성, 데이터 타입/기본값/null/check
    * 업무 무결성
        * 주로 app 계층에서 점검, db에서는 트리거
* 1.30. 성능에 대해서


## 02 정규화 이야기
* 2.1. 정규화에 대한 서설
* 2.2. 정규화란?
* 2.3. 함수 종속이란?
* 2.4. 결정자와 종속자
* 2.5. 함수 종속과 폐포
* 2.6. 함수 종속과 정규화
* 2.7. 그냥 릴레이션과 비정규형 릴레이션
* 2.8. 등산과 정규화
* 2.9. 정규화를 하면 좋아지는 게 무엇인가?
* 2.10. 아노말리란?
* 2.11. 정규형의 종류
* 2.12. 1정규화와 원자 값
* 2.13. 1정규화의 대상
* 2.14. 1정규형과 비정규형
* 2.15. 반복 속성으로 인한 1정규형 위반 사례
* 2.16. 2정규형
* 2.17. 2정규형 위반인가?
* 2.18. 3정규형
* 2.19. BC정규형
* 2.20. 4정규형
* 2.21. 5정규형
* 2.22. 정규화 요약
* 2.23. 3정규화까지만 수행하면 된다?
* 2.24. 정규형과 성능


## 03 데이터 통합과 서브타입 이야기
* 3.1. 데이터 통합에 대한 서설
* 3.2. 일반화와 상세화
* 3.3. 데이터 통합과 엔터티 통합
* 3.4. 통합이 대세인가?
* 3.5. 어떤 경우에 통합을 고려하는가?
* 3.6. 통합을 고려하지 않아도 되는 경우
* 3.7. 데이터 통합이 어려운 또 다른 이유
* 3.8. 데이터 주제 영역이란?
* 3.9. 주제 영역 설계 방법
* 3.10. 데이터 오너십과 모델 오너십
* 3.11. 데이터 통합의 시발점
* 3.12. 데이터 통합과 정규화
* 3.13. 통합과 합체
* 3.14. 주 식별자가 다른 엔터티의 통합
* 3.15. 서브타입에 대한 서설
* 3.16. 서브타입과 부분집합
* 3.17. 서브타입은 어떻게 도출하는가?
* 3.18. 왜 서브타입을 사용하는가?
* 3.19. 한 엔터티에 서브타입이 여러 개 존재한다?
* 3.20. 서브타입과 코드
* 3.21. Is-A 서브타입과 Part-Of 서브타입
* 3.22. 배타 서브타입과 중복 서브타입
* 3.23. 배타 서브타입과 이력 데이터
* 3.24. 중복 서브타입에 대한 설계
* 3.25. 중복 서브타입의 주의점
* 3.26. 완전 서브타입과 불완전 서브타입
* 3.27. 서브타입과 슈퍼타입의 관계
* 3.28. 서브타입의 오해 ? 슈퍼타입과 서브타입은 부모 자식 관계다
* 3.29. 슈퍼타입?서브타입 논리 모델의 물리 모델 변환
* 3.30. 서브타입 모델의 물리 모델 변환 - 서브타입별로 엔터티 분할
* 3.31. 서브타입 모델의 물리 모델 변환 - 슈퍼타입 엔터티로 통합
* 3.32. 서브타입 모델의 물리 모델 변환 - 슈퍼타입?서브타입 개별 생성
* 3.33. 서브타입 모델의 물리 모델 변환 - 슈퍼타입?서브타입 개별 생성(배타 관계)
* 3.34. ERWin 툴의 서브타입 표기법
* 3.35. 중첩 서브타입
* 3.36. 서브타입 간의 관계 표현법
* 3.37. 잘못된 서브타입
* 3.38. 범주에 대해서


## 04 속성 이야기
* 4.1. 속성에 대한 서설
* 4.2. 식별자 속성과 비식별자 속성
* 4.3. 식별자 종류 ? 후보 식별자
* 4.4. 식별자 종류 ? 주 식별자
* 4.5. 주 식별자가 바뀌는 현상
* 4.6. 어떤 속성을 주 식별자로 선택해야 하는가?
* 4.7. 주 식별자를 단순하게 설계해야 하는 이유
* 4.8. 주 식별자 선정 절차
* 4.9. 복잡한 주 식별자
* 4.10. 복합 주 식별자의 속성 순서
* 4.11. 교차 엔터티의 주 식별자
* 4.12. 사원 엔터티의 주 식별자와 사원의 정의에 대해서
* 4.13. 식별자 종류 ? 인조 식별자
* 4.14. 인조 식별자를 사용해야 좋을 때
* 4.15. 업무 식별자와 인조 식별자의 혼합
* 4.16. 부분 인조 식별자를 사용할 수 있는 경우
* 4.17. 식별자 종류 ? 대리 식별자
* 4.18. 식별자 종류 ? 슈퍼 식별자
* 4.19. 속성 종류 ? 기초 속성
* 4.20. 속성 종류 ? 관계 속성
* 4.21. 속성 종류 ? 추출 속성
* 4.22. 속성 종류 ? 시스템 속성
* 4.23. 추출 속성의 종류 ? 중복 속성
* 4.24. 시점 데이터가 중복 속성이다?
* 4.25. 중복 속성을 사용할 수 있는 경우
* 4.26. 단일 값 속성과 다가 속성
* 4.27. 단순 속성과 복합 속성
* 4.28. 필수 속성과 선택 속성
* 4.29. 배타 속성
* 4.30. 코드 속성과 비코드 속성
* 4.31. 일반 코드와 식별자 코드
* 4.32. 식별자 코드와 일반 코드의 관리
* 4.33. 식별자 코드와 일반 코드의 상호 변환
* 4.34. 통합 코드로 설계할지 개별 엔터티로 설계할지?
* 4.35. 코드 속성의 명명법
* 4.36. 코드 인스턴스 설계 원칙
* 4.37. 코드를 사용하는 용도
* 4.38. 코드 엔터티와 참조 무결성 관계
* 4.39. 통합 코드 엔터티와 개별 코드 엔터티
* 4.40. 일반적인 코드 모델
* 4.41. 전체 코드의 부분집합을 관리하는 모델
* 4.42. 코드 값 간 관계를 관리하는 코드 모델
* 4.43. 출력 순서를 관리하는 코드 모델
* 4.44. 코드 모델의 이력 관리
* 4.45. 속성 명은 어떻게 정하는가?
* 4.46. 속성 설명
* 4.47. 속성 표준화
* 4.48. 도메인
* 4.49. 데이터 타입 선정 원칙과 절차
* 4.50. 널에 대한 서설
* 4.51. 널과 DBMS와 인덱스
* 4.52. 널 특징과 사용법
* 4.53. 속성 검증


## 05 관계 이야기
* 5.1. 관계에 대한 서설
* 5.2. 관계선이 의미하는 것
* 5.3. 관계를 설계할 때 고려할 사항
* 5.4. 참조 무결성
* 5.5. 기준 엔터티의 참조 무결성
* 5.6. 종속 관계와 참조 관계
* 5.7. 식별 관계와 비식별 관계
* 5.8. 종속?참조 관계와 식별?비식별 관계
* 5.9. 식별 관계와 비식별 관계를 채택하는 예외 경우
* 5.10. 관계 속성과 관계 엔터티
* 5.11. 관계 엔터티의 특징
* 5.12. 관계 엔터티 선택 기준
* 5.13. 관계선의 구성 요소
* 5.14. 관계 구성 요소 - 관계비
* 5.15. 관계비 분석 방법
* 5.16. 관계 구성 요소 - 관계 존재성
* 5.17. 상위 엔터티의 관계 존재성
* 5.18. 관계비와 관계 존재성의 표기법
* 5.19. 관계 존재성과 관계 속성의 널 제약
* 5.20. 관계 구성 요소 ? 관계 참여수
* 5.21. 관계 참여수와 주 식별자
* 5.22. 관계 참여수와 연관된 다앙한 설계 방법
* 5.23. 관계 명
* 5.24. 관계 명 붙이는 방법
* 5.25. 관계 명이 필요할 때와 필요 없을 때
* 5.26. 일대일 관계
* 5.27. 일대일 관계와 이력 데이터
* 5.28. 배타 관계
* 5.29. 주 식별자가 다른 엔터티의 배타 관계
* 5.30. 재귀 관계
* 5.31. 재귀 관계의 관계비
* 5.32. 재귀 관계에서의 데이터 발생 규칙
* 5.33. 분류 계층 모델
* 5.34. 추출 관계
* 5.35. 양방향 관계
* 5.36. 잘못 설계한 관계선
* 5.37. 잘못 설계한 관계선의 다양한 예제
* 5.38. 관계 검증


## 06 이력 데이터 이야기
* 6.1. 이력 데이터에 대한 서설
* 6.2. 이력 데이터와 내역 데이터
* 6.3. 이력 엔터티 설계 시점
* 6.4. 이력 데이터를 설계하는 방법
* 6.5. 이력 데이터를 설계하는 첫 번째 방법
* 6.6. 이력 데이터를 설계하는 두 번째 방법
* 6.7. 이력 데이터를 설계하는 세 번째 방법
* 6.8. 이력 데이터를 설계하는 네 번째 방법
* 6.9. 속성 단위의 이력 모델과 추출 속성
* 6.10. 속성 그룹 단위로 이력 데이터를 설계하는 예제
* 6.11. 이력 데이터를 설계하는 다섯 번째 방법
* 6.12. 이력 데이터를 종 테이블로 설계하는 다양한 방법
* 6.13. 함께 변경된 속성을 알아야 할 때
* 6.14. 선분이력
* 6.15. 선분이력의 종료일자
* 6.16. 기간을 의미하는 종료 일자
* 6.17. 이력 엔터티의 주 식별자
* 6.18. 이력 엔터티 설계 절차
* 6.19. 서브타입의 이력 모델
* 6.20. 정정 데이터


## 07 비정규화 이야기
* 7.1. 비정규화에 대한 서설
* 7.2. 비정규화 원칙
* 7.3. 비정규형의 단점
* 7.4. 비정규화 과정
* 7.5. 비정규화 방법 - 역정규화
* 7.6. 비정규화 방법 - 엔터티 합체
* 7.7. 비정규화 방법 - 엔터티 분해
* 7.8. 비정규화 방법 - 요약 엔터티
* 7.9. 비정규화 방법 - 추출 속성
* 7.10. 이전 값을 관리하는 모델을 설계하는 방법
* 7.11. 비정규화 방법 - 추출 엔터티
* 7.12. 비정규화 방법 - 반복 속성
* 7.13. 비정규화 방법 - 중복 데이터