## [Part I 전제]
### CHAPTER 1 소프트웨어 엔지니어링이란?
* 1.1 시간과 변경
* 1.2 규모 확장과 효율성
* 1.3 트레이드오프와 비용
* 1.4 소프트웨어 엔지니어링 vs 프로그래밍
* 1.5 마치며
* 1.6 핵심 정리

## [Part II 문화]
### CHAPTER 2 팀워크 이끌어내기
* 2.1 내 코드를 숨기고 싶어요
* 2.2 천재 신화
* 2.3 숨기는 건 해롭다
* 2.4 모든 건 팀에 달렸다
* 2.5 마치며
* 2.6 핵심 정리

### CHAPTER 3 지식 공유
* 3.1 배움을 가로막는 장애물
* 3.2 철학
* 3.3 판 깔아주기: 심리적 안전
* 3.4 내 지식 키우기
* 3.5 질문 확장하기: 커뮤니티에 묻기
* 3.6 지식 확장하기: 누구나 가르칠 게 있다
* 3.7 조직의 지식 확장하기
* 3.8 가독성 제도: 코드 리뷰를 통한 표준 멘토 제도
* 3.9 마치며
* 3.10 핵심 정리

### CHAPTER 4 공정 사회를 위한 엔지니어링
* 4.1 편견은 피할 수 없다
* 4.2 다양성이 필요한 이유 이해하기
* 4.3 다문화 역량 갖추기
* 4.4 다양성 실천하기
* 4.5 단일한 접근 방식 거부하기
* 4.6 확립된 프로세스에 도전하기
* 4.7 가치 vs 결과
* 4.8 관심을 잃지 말고 전진하자
* 4.9 마치며
* 4.10 핵심 정리

### CHAPTER 5 팀 이끌기
* 5.1 관리자와 테크 리드(혹은 둘 다)
* 5.2 개인 기여자에서 리더로
* 5.3 엔지니어링 관리자
* 5.4 안티패턴
* 5.5 올바른 패턴
* 5.6 예상 못한 질문
* 5.7 그 외 조언과 요령
* 5.8 사람은 식물과 같다
* 5.9 마치며
* 5.10 핵심 정리

### CHAPTER 6 성장하는 조직 이끌기
* 6.1 늘 결정하라(Always Be Deciding)
* 6.2 늘 떠나라(Always Be Leaving)
* 6.3 늘 확장하라(Always Be Scaling)
* 6.4 마치며
* 6.5 핵심 정리

### CHAPTER 7 엔지니어링 생산성 측정하기
* 7.1 엔지니어링 생산성을 측정하는 이유
* 7.2 선별: 측정할 가치가 있는가?
* 7.3 GSM 프레임워크: 목표와 신호를 뒷받침하는 의미 있는 지표 선정하기
* 7.4 목표(goal)
* 7.5 신호(signal)
* 7.6 지표(metric)
* 7.7 데이터로 지표 검증하기
* 7.8 조치를 취하고 결과 추적하기
* 7.9 마치며
* 7.10 핵심 정리

## [Part III 프로세스]
### CHAPTER 8 스타일 가이드와 규칙
* 8.1 규칙이 필요한 이유
* 8.2 규칙 만들기
* 8.3 규칙 수정하기
* 8.4 지침
* 8.5 규칙 적용하기
* 8.6 마치며
* 8.7 핵심 정리

### CHAPTER 9 코드 리뷰
* 9.1 코드 리뷰 흐름
* 9.2 코드 리뷰 @ 구글
* 9.3 코드 리뷰의 이점
* 9.4 코드 리뷰 모범 사례
* 9.5 코드 리뷰 유형
* 9.6 마치며
* 9.7 핵심 정리

### CHAPTER 10 문서자료
* 10.1 문서자료란?
* 10.2 문서자료가 필요한 이유
* 10.3 문서자료는 코드와 같다
* 10.4 독자를 알라
* 10.5 문서자료 유형
* 10.6 문서자료 리뷰
* 10.7 문서화 철학
* 10.8 테크니컬 라이터가 필요한 순간
* 10.9 마치며
* 10.10 핵심 정리

### CHAPTER 11 테스트 개요
* 11.1 테스트를 작성하는 이유
* 11.2 테스트 스위트 설계하기
* 11.3 구글 규모의 테스트
* 11.4 구글의 테스트 역사
* 11.5 자동 테스트의 한계
* 11.6 마치며
* 11.7 핵심 정리

### CHAPTER 12 단위 테스트
* 12.1 유지보수하기 쉬워야 한다
* 12.2 깨지기 쉬운 테스트 예방하기
* 12.3 명확한 테스트 작성하기
* 12.4 테스트와 코드 공유: DRY가 아니라 DAMP!
* 12.5 마치며
* 12.6 핵심 정리

### CHAPTER 13 테스트 대역
* 13.1 테스트 대역이 소프트웨어 개발에 미치는 영향
* 13.2 테스트 대역 @ 구글
* 13.3 기본 개념
* 13.4 테스트 대역 활용 기법
* 13.5 실제 구현
* 13.6 속이기(가짜 객체)
* 13.7 뭉개기(스텁)
* 13.8 상호작용 테스트하기
* 13.9 마치며
* 13.10 핵심 정리

### CHAPTER 14 더 큰 테스트
* 14.1 더 큰 테스트란?
* 14.2 더 큰 테스트 @ 구글
* 14.3 큰 테스트의 구조
* 14.4 더 큰 테스트 유형
* 14.5 큰 테스트와 개발자 워크플로
* 14.6 마치며
* 14.7 핵심 정리

### CHAPTER 15 폐기
* 15.1 폐기시키는 이유
* 15.2 폐기는 왜 그리 어려운가?
* 15.3 폐기 유형
* 15.4 폐기 프로세스 관리
* 15.5 마치며
* 15.6 핵심 정리

## [Part IV 도구]
### CHAPTER 16 버전 관리와 브랜치 관리
* 16.1 버전 관리란?
* 16.2 브랜치 관리
* 16.3 버전 관리 @ 구글
* 16.4 모노리포(단일 리포지터리)
* 16.5 버전 관리의 미래
* 16.6 마치며
* 16.7 핵심 정리

### CHAPTER 17 Code Search
* 17.1 Code Search UI
* 17.2 구글 개발자가 Code Search를 이용하는 방법
* 17.3 독립된 웹 도구로 만든 이유
* 17.4 규모가 설계에 미치는 영향
* 17.5 구글은 어떻게 구현했나?
* 17.6 구글이 선택한 트레이드오프
* 17.7 마치며
* 17.8 핵심 정리

### CHAPTER 18 빌드 시스템과 빌드 철학
* 18.1 빌드 시스템의 목적
* 18.2 빌드 시스템이 없다면?
* 18.3 모던 빌드 시스템
* 18.4 모듈과 의존성 다루기
* 18.5 마치며
* 18.6 핵심 정리

### CHAPTER 19 Critique: 구글의 코드 리뷰 도구
* 19.1 코드 리뷰 도구 원칙
* 19.2 코드 리뷰 흐름
* 19.3 1단계: 변경 생성
* 19.4 2단계: 리뷰 요청
* 19.5 3~4단계: 변경 이해하고 댓글 달기
* 19.6 5단계: 변경 승인(변경에 점수 매기기)
* 19.7 6단계: 변경 커밋
* 19.8 마치며
* 19.9 핵심 정리

### CHAPTER 20 정적 분석
* 20.1 효과적인 정적 분석의 특징
* 20.2 정적 분석을 적용하며 깨우친 핵심 교훈
* 20.3 Tricorder: 구글의 정적 분석 플랫폼
* 20.4 마치며
* 20.5 핵심 정리

### CHAPTER 21 의존성 관리
* 21.1 의존성 관리가 어려운 이유
* 21.2 의존성 임포트하기
* 21.3 (이론상의) 의존성 관리
* 21.4 유의적 버전의 한계
* 21.5 자원이 무한할 때의 의존성 관리
* 21.6 마치며
* 21.7 핵심 정리

### CHAPTER 22 대규모 변경
* 22.1 대규모 변경이란?
* 22.2 누가 대규모 변경을 처리하나?
* 22.3 원자적 변경을 가로막는 요인
* 22.4 대규모 변경 인프라
* 22.5 대규모 변경 프로세스
* 22.6 마치며
* 22.7 핵심 정리

### CHAPTER 23 지속적 통합
* 23.1 지속적 통합이란?
* 23.2 지속적 통합 @ 구글
* 23.3 마치며
* 23.4 핵심 정리

### CHAPTER 24 지속적 배포
* 24.1 지속적 배포 이디엄 @ 구글
* 24.2 속도는 팀 스포츠다: 배포를 관리 가능한 조각으로 나누기
* 24.3 변경을 격리해 평가하자: 기능 플래그로 보호하기
* 24.4 기민해지기 위한 분투: 릴리스 열차 갖추기
* 24.5 품질과 사용자에 집중: 사용할 기능만 배포하자
* 24.6 원점 회귀: 데이터에 기초해 더 일찍 결정하자
* 24.7 팀 문화 바꾸기: 배포 규율 세우기
* 24.8 마치며
* 24.9 핵심 정리

### CHAPTER 25 서비스형 컴퓨트
* 25.1 컴퓨트 환경 길들이기
* 25.2 관리형 컴퓨트에 적합한 소프트웨어 작성하기
* 25.3 시간과 규모에 따른 CaaS
* 25.4 컴퓨트 서비스 선택하기
* 25.5 마치며
* 25.6 핵심 정리 