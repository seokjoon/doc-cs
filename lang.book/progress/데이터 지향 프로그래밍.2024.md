# 1부 유연성

## 1장 객체지향 프로그래밍의 복잡성
* 1.1 OOP 설계: 정통인가? 고전인가?
	* 1.1.1 설계 단계
* 1.1.2 UML 기초
	* 1.1.3 클래스도 상세 설명
	* 1.1.4 구현 단계
* 1.2 복잡성의 근원
	* 근원
		* 코드와 데이터가 섞임: 클래스가 많은 관계에 연루
		* 객체 변경 가능: 코드 리딩시 더 많은 생각 필요, 다중 스레드 환경에서 명시적 동기화 필요
		* 데이터가 멤버로 객체에 고정: 데이터 직렬화 어려움
		* 코드는 메서드로 클래스에 고정: 클래스 계층 구조 복잡
	* 1.2.1 다량의 클래스 간 관계
	* 1.2.2 예상치 못한 코드 동작
	* 1.2.3 쉽지 않은 데이터 직렬화
	* 1.2.4 복잡한 클래스 계층 구조


## 2장 코드와 데이터 분리
* 2.1 DOP 시스템의 두 부분
* 2.2 데이터 개체
* 2.3 코드 모듈
* 2.4 이해하기 쉬운 DOP 시스템
* 2.5 유연한 DOP 시스템


## 3장 기본 데이터 조작
* 3.1 데이터 모델 설계
* 3.2 맵으로 관리되는 레코드
* 3.3 범용 함수를 사용한 데이터 조작
* 3.4 검색 결과 연산
* 3.5 이종 자료형의 레코드 처리


## 4장 상태 관리
* 4.1 다중 버전 시스템 데이터
* 4.2 구조적 공유
* 4.3 구조적 공유 구현
* 4.4 데이터 안전성
* 4.5 변경의 반영 단계
* 4.6 시스템 상태 무결성 보장
* 4.7 이전 상태 복원


## 5장 기본 동시성 제어
* 5.1 낙관적 동시성 제어
* 5.2 동시 변경 조정
* 5.3 컬렉션 축소
* 5.4 구조적 비교
* 5.5 조정 알고리듬 구현


## 6장 단위 테스트
* 6.1 간결한 데이터 지향 테스트 케이스
* 6.2 데이터 조작 코드의 단위 테스트
	* 6.2.1 함수 호출 트리
	* 6.2.2 끝 단 함수의 단위 테스트
	* 6.2.3 트리 중간 노드의 단위 테스트
* 6.3 조회 함수의 단위 테스트
* 6.4 변경의 단위 테스트
* 다음 단계


## 2부 확장성
* 7장 기본 데이터 유효성 확인
* 7.1 DOP의 데이터 유효성 확인
* 7.2 JSON 스키마 소개
* 7.3 유연하고도 엄격한 스키마
* 7.4 스키마 합성
* 7.5 데이터 유효성 오류 상세 정보


## 8장 고급 동시성 제어
* 8.1 복잡한 잠금
* 8.2 스레드 안전한 원자 계수기
* 8.3 스레드 안전한 원자 캐시
* 8.4 원자 기반 상태 관리


## 9장 영속 자료구조
* 9.1 영속 자료구조의 필요성
* 9.2 영속 자료구조의 효율성
* 9.3 영속 자료구조 라이브러리
* 9.3.1 자바 영속 자료구조
* 9.3.2 자바스크립트 영속 자료구조
* 9.4 실무 영속 자료구조
* 9.4.1 영속 자료구조를 사용한 조회 코드
* 9.4.2 영속 자료구조를 사용한 변경 코드
* 9.4.3 직렬화와 역직렬화
* 9.4.4 구조적 비교


## 10장 데이터베이스 작업
* 10.1 데이터베이스에서 데이터를 가져오는 작업
* 10.2 데이터베이스에 데이터 저장하기
* 10.3 단순한 데이터 조작
* 10.4 복잡한 데이터 조작


# 11장 웹 서비스
* 11.1 또 다른 기능 요청
* 11.2 외부와 동일한 내부 구축
* 11.3 맵으로 표현되는 클라이언트 요청
* 11.4 맵으로 표현되는 서버 응답
* 11.5 정보 전달
* 11.6 실제 검색 결과 보강
* 일정 준수


## 3부 유지보수성
* 12장 고급 데이터 유효성 확인
* 12.1 함수 인자 유효성 확인
* 12.2 반환값 유효성 확인
* 12.3 고급 데이터 유효성 확인
* 12.4 데이터 모델 도식 자동 생성
* 12.5 스키마 기반 단위 테스트 자동 생성
* 12.6 새로운 선물


## 13장 다형성
* 13.1 다형성의 핵심
* 13.2 단일 디스패치 다중 메서드
* 13.3 다중 디스패치 다중 메서드
* 13.4 동적 디스패치 다중 메서드
* 13.5 실운영 시스템에 다중 메서드 통합


## 14장 고급 데이터 조작
* 14.1 풍부한 표현의 맵 값 갱신
* 14.2 중첩된 데이터 조작
* 14.3 최적의 도구 사용
* 14.4 배열 필드 해체


## 15장 디버그
* 15.1 프로그래밍 결정론
* 15.2 숫자와 문자열을 사용한 재현
* 15.3 모든 데이터 유형에서 재현
* 15.4 단위 테스트
* 15.5 외부 데이터 테스트
* 작별


##
* 부록 A 데이터 지향 프로그래밍 원리
* 부록 B 정적 타입 언어의 범용 데이터 접근
* 부록 C 패러다임의 발전과 데이터 지향 프로그래밍
* 부록 D 로대시
