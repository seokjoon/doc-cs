# 1장 모놀리식 지옥에서 벗어나라

## 1.4 마이크로서비스 아키텍처가 답이다
* 1.4.1 확장 큐브와 마이크로서비스
    * X축(다중 인스턴스에 요청 분산), Z축(요청 속성별 라우팅), Y축(기능에 따라 앱을 서비스로 분해)
* 1.4.2 마이크로서비스는 모듈성을 갖고 있다
    * api가 경계선
* 1.4.3 서비스마다 DB가 따로 있다

## 1.5 마이크로서비스 아키텍처의 장단점

## 1.6 마이크로서비스 아키텍처 패턴 언어
* 1.6.2 패턴 및 패턴 언어
    * 강제 조항, 결과 맥락, 연관 패턴(선행자, 후행자, 대안, 일반화, 세분화)
* 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요
    * 인프라 패턴, 애플리케이션 인프라, 애플리케이션 패턴
    * 통신 패턴, 트랜잭션 관리를 위한 데이터 일관성 패턴(saga), 데이터 쿼리 패턴, 서비스 배포 패턴, 관측성 패턴, 서비스 테스트 자동화 패턴, 횡단 관심사 처리 패턴, 보안 패턴

## 1.7 마이크로서비스 너머: 프로세스와 조직
* 1.7.2 소프트웨어 개발/전달 프로세스
    * SW 개발 수준: 배포 빈도, 리드 타입, 평균 복구 시간, 변경분 실패율



## 2장 분해 전략

## 2.1 마이크로서비스 아키텍처란 무엇인가?
* 2.1.1 소프트웨어 아키텍처의 정의와 중요성
    * 4+1뷰 모델: 논리 뷰, 구현 뷰, 프로세스 뷰, 배포 뷰

## 2.2 마이크로서비스 아키텍처 정의
* 2.2.1 시스템 작업 식별
    * 도메인 모델 생성, 비즈니스 능력 식별, 능력을 여러 서비스로 매핑
* 2.2.2 서비스 정의: 비즈니스 능력 패턴별 분해
* 2.2.3 서비스 정의: 하위 도메인 패턴별 분해
* 2.2.4 분해 지침
    * 단일 책임 원칙, 공동 폐쇄 원칙
    * 서비스 분해 패턴 2가지: 비즈니스(능력/아키텍처) 기반, DDD(하위도메인) 기반
* 2.2.5 서비스 분해의 장애물
* 2.2.6 서비스 API 정의



## 3장 프로세스 간 통신

## 3.1 마이크로서비스 아키텍처 IPC 개요
* 3.1.1 상호 작용 스타일
    * 일대일/일대다: 요청을 처리하는 서비스 개수
        * 일대일: 요청/응답, 비동기 요청/응답, 단방향 알림
        * 일대다: 발행/구독, 발행/비동기 응답
    * 동기/비동기
* 3.1.2 마이크로서비스 API 정의
* 3.1.3 API 발전시키기
* 3.1.4 메시지 포맷

## 3.2 동기 RPI 패턴 응용 통신
* 3.2.1 동기 RPI 패턴: REST
* 3.2.2 동기 RPI 패턴: gRPC
* 3.2.3 부분 실패 처리: 회로 차단기 패턴
    * 타임아웃, 미처리 개수 제한, 회로 차단기 패턴
* 3.2.4 서비스 디스커버리

## 3.3 비동기 메시징 패턴 응용 통신
* 3.3.1 메시징 개요
    * 메시지: 문서, 커맨드, 이벤트
    * 채널: 점대점, 발행-구독
* 3.3.2 메시징 상호 작용 스타일 구현
    * 요청/응답(동기/비동기), 단방향 알림, 발행/구독, 발행/비동기응답
* 3.3.3 메시징 기반 서비스의 API 명세 작성
* 3.3.4 메시지 브로커
    * 서비스 간 통신 인프라
    * activeMQ, RabbitMQ, apache Kafka
    * aws kinesis, aws SQS
* 3.3.5 수신자 경합과 메시지 순서 유지
* 3.3.6 중복 메시지 처리
* 3.3.7 트랜잭셔널 메시징
* 3.3.8 메시징 라이브러리/프레임워크

## 3.4 비동기 메시징으로 가용성 개선
* 3.4.1 동기 통신으로 인한 가용성 저하
* 3.4.2 동기 상호 작용 제거



## 4장 트랜잭션 관리: 사가

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리
* 4.1.1 분산 트랜잭션의 필요성
* 4.1.2 분산 트랜잭션의 문제점
* 4.1.3 데이터 일관성 유지: 사가 패턴

## 4.2 사가 편성
* 4.2.1 코레오그래피 사가
* 4.2.2 오케스트레이션 사가
## 4.3 비격리 문제 처리
* 4.3.1 비정상 개요
* 4.3.2 비격리 대책
## 4.4 주문 서비스 및 주문 생성 사가 설계
* 4.4.1 OrderService 클래스
* 4.4.2 주문 생성 사가 구현
* 4.4.3 OrderCommandHandlers 클래스
* 4.4.4 OrderServiceConfiguration 클래스



## 5장 비즈니스 로직 설계

## 5.1 비즈니스 로직 구성 패턴
* 5.1.1 비즈니스 로직 설계: 트랜잭션 스크립트 패턴
* 5.1.2 비즈니스 로직 설계: 도메인 모델 패턴
* 5.1.3 도메인 주도 설계 개요

## 5.2 도메인 모델 설계: DDD 애그리거트 패턴
* 5.2.1 불분명한 경계 문제
* 5.2.2 애그리거트는 경계가 분명하다
* 5.2.3 애그리거트 규칙
* 5.2.4 애그리거트 입도
* 5.2.5 비즈니스 로직 설계: 애그리거트

## 5.3 도메인 이벤트 발행
* 5.3.1 변경 이벤트를 발행하는 이유
* 5.3.2 도메인 이벤트란 무엇인가?
* 5.3.3 이벤트 강화
* 5.3.4 도메인 이벤트 식별
* 5.3.5 도메인 이벤트 생성 및 발행
* 5.3.6 도메인 이벤트 소비

## 5.4 주방 서비스 비즈니스 로직
* 5.4.1 Ticket 애그리거트

## 5.5 주문 서비스 비즈니스 로직
* 5.5.1 Order 애그리거트
* 5.5.2 OrderService 클래스



## 6장 비즈니스 로직 개발: 이벤트 소싱

## 6.1 이벤트 소싱 응용 비즈니스 로직 개발
* 6.1.1 기존 영속화의 문제점
* 6.1.2 이벤트 소싱 개요
* 6.1.3 동시 업데이트: 낙관적 잠금
* 6.1.4 이벤트 소싱과 이벤트 발행
* 6.1.5 스냅샷으로 성능 개선
* 6.1.6 멱등한 메시지 처리
* 6.1.7 도메인 이벤트 발전시키기
* 6.1.8 이벤트 소싱의 장점
* 6.1.9 이벤트 소싱의 단점

## 6.2 이벤트 저장소 구현
* 6.2.1 이벤추에이트 로컬 이벤트 저장소의 작동 원리
* 6.2.2 자바용 이벤추에이트 클라이언트 프레임워크

## 6.3 사가와 이벤트 소싱을 접목
* 6.3.1 코레오그래피 사가 구현: 이벤트 소싱
* 6.3.2 오케스트레이션 사가 생성
* 6.3.3 이벤트 소싱 기반의 사가 참여자 구현
* 6.3.4 사가 오케스트레이터 구현: 이벤트 소싱



## 7장 마이크로서비스 쿼리 구현

## 7.1 API 조합 패턴 응용 쿼리
* 7.1.1 findOrder( ) 쿼리
* 7.1.2 API 조합 패턴 개요
* 7.1.3 API를 조합 패턴으로 findOrder( ) 쿼리 구현
* 7.1.4 API 조합 설계 이슈
* 7.1.5 API 조합 패턴의 장단점

## 7.2 CQRS 패턴
* 7.2.1 CQRS의 필요성
* 7.2.2 CQRS 개요
* 7.2.3 CQRS의 장점
* 7.2.4 CQRS의 단점

## 7.3 CQRS 뷰 설계
* 7.3.1 뷰 DB 선택
* 7.3.2 데이터 접근 모듈 설계
* 7.3.3 CQRS 뷰 추가 및 업데이트

## 7.4 CQRS 뷰 구현: AWS DynamoDB 응용
* 7.4.1 OrderHistoryEventHandlers 모듈
* 7.4.2 DynamoDB 데이터 모델링 및 쿼리 설계
* 7.4.3 OrderHistoryDaoDynamoDb 클래스



## 8장 외부 API 패턴

## 8.1 외부 API 설계 이슈
* 8.1.1 API 설계 이슈: FTGO 모바일 클라이언트
* 8.1.2 API 설계 이슈: 다른 종류의 클라이언트

## 8.2 API 게이트웨이 패턴
* 8.2.1 API 게이트웨이 패턴 개요
* 8.2.2 API 게이트웨이의 장단점
* 8.2.3 API 게이트웨이 사례: 넷플릭스
* 8.2.4 API 게이트웨이 설계 이슈

## 8.3 API 게이트웨이 구현
* 8.3.1 기성 API 게이트웨이 제품/서비스 활용
* 8.3.2 API 게이트웨이 자체 개발
* 8.3.3 API 게이트웨이 구현: GraphQL



## 9장 마이크로서비스 테스트 1부

## 9.1 마이크로서비스 아키텍처 테스트 전략
* 9.1.1 테스트 개요
* 9.1.2 마이크로서비스 테스트
* 9.1.3 배포 파이프라인

## 9.2 서비스 단위 테스트 작성
* 9.2.1 단위 테스트 작성: 엔터티
* 9.2.2 단위 테스트 작성: 밸류 객체
* 9.2.3 단위 테스트 작성: 사가
* 9.2.4 단위 테스트 작성: 도메인 서비스
* 9.2.5 단위 테스트 작성: 컨트롤러
* 9.2.6 단위 테스트 작성: 이벤트/메시지핸들러



## 10장 마이크로서비스 테스트 2부

## 10.1 통합 테스트 작성
* 10.1.1 통합 테스트: 영속화
* 10.1.2 통합 테스트: REST 요청/응답형 상호 작용
* 10.1.3 통합 테스트: 발행/구독 스타일 상호 작용
* 10.1.4 통합 계약 테스트: 비동기 요청/응답 상호 작용

## 10.2 컴포넌트 테스트 개발
* 10.2.1 인수 테스트 정의
* 10.2.2 인수 테스트 작성: 거킨
* 10.2.3 컴포넌트 테스트 설계
* 10.2.4 컴포넌트 테스트 작성: 주문 서비스

## 10.3 종단 간 테스트 작성
* 10.3.1 종단 간 테스트 설계
* 10.3.2 종단 간 테스트 작성
* 10.3.3 종단 간 테스트 실행


## 11장 프로덕션 레디 서비스 개발

## 11.1 보안 서비스 개발
* 11.1.1 기존 모놀리식 애플리케이션의 보안
* 11.1.2 마이크로서비스 아키텍처에서의 보안 구현

## 11.2 구성 가능한 서비스 설계
* 11.2.1 푸시 기반의 외부화 구성
* 11.2.2 풀 기반의 외부화 구성

## 11.3 관측 가능한 서비스 설계
* 11.3.1 헬스 체크 API 패턴
* 11.3.2 로그 수집 패턴
* 11.3.3 분산 추적 패턴
* 11.3.4 애플리케이션 지표 패턴
* 11.3.5 예외 추적 패턴
* 11.3.6 감사 로깅 패턴



## 11.4 서비스 개발: 마이크로서비스 섀시 패턴
* 11.4.1 마이크로서비스 섀시
* 11.4.2 이제는 서비스 메시로



## 12장 마이크로서비스 배포

## 12.1 서비스 배포: 언어에 특정한 패키징 포맷 패턴
* 12.1.1 언어에 특정한 패키징 포맷 패턴의 장점
* 12.1.2 언어에 특정한 패키징 포맷 패턴의 단점

## 12.2 서비스 배포: 가상 머신 패턴
* 12.2.1 가상 머신 패턴의 장점
* 12.2.2 가상 머신 패턴의 단점

## 12.3 서비스 배포: 컨테이너 패턴
* 12.3.1 서비스를 도커로 배포
* 12.3.2 컨테이너 패턴의 장점
* 12.3.3 컨테이너 패턴의 단점

## 12.4 FTGO 애플리케이션 배포: 쿠버네티스
* 12.4.1 쿠버네티스 개요
* 12.4.2 쿠버네티스 배포: 음식점 서비스
* 12.4.3 API 게이트웨이 배포
* 12.4.4 무중단 배포
* 12.4.5 배포와 릴리스 분리: 서비스 메시

## 12.5 서비스 배포: 서버리스 패턴
* 12.5.1 AWS 람다를 이용한 서버리스 배포
* 12.5.2 람다 함수 개발
* 12.5.3 람다 함수 호출
* 12.5.4 람다 함수의 장점
* 12.5.5 람다 함수의 단점

## 12.6 REST 서비스 배포: AWS 람다 및 AWS 게이트웨이
* 12.6.1 음식점 서비스를 AWS 람다 버전으로 설계
* 12.6.2 ZIP 파일로 서비스 패키징
* 12.6.3 서버리스 프레임워크로 람다 함수 배포



## 13장 마이크로서비스로 리팩터링

## 13.1 마이크로서비스 리팩터링 개요
* 13.1.1 모놀리스를 왜 리팩터링하는가?
* 13.1.2 모놀리스 옥죄기

## 13.2 모놀리스 → 마이크로서비스 리팩터링 전략
* 13.2.1 새 기능을 서비스로 구현한다
* 13.2.2 표현 계층과 백엔드를 분리한다
* 13.2.3 기능을 여러 서비스로 추출한다

## 13.3 서비스와 모놀리스 간 협동 설계
* 13.3.1 통합 글루 설계
* 13.3.2 서비스와 모놀리스에 걸쳐 데이터 일관성 유지
* 13.3.3 인증/인가 처리

## 13.4 새 기능을 서비스로 구현: 배달 실패한 주문 처리
* 13.4.1 배달 지연 서비스 설계
* 13.4.2 배달 지연 서비스를 위한 통합 글루 설계

## 13.5 모놀리스 분해: 배달 관리 추출
* 13.5.1 현행 배달 관리 기능
* 13.5.2 배달 서비스 개요
* 13.5.3 배달 서비스의 도메인 모델 설계
* 13.5.4 배달 서비스의 통합 글루 설계
* 13.5.5 배달 서비스와 상호 작용할 수 있게 모놀리스를 변경



## 한국어판 부록 a 실습 환경 구성

## A.1 실습 준비
* A.1.1 운영 체제: 윈도 10 Pro
* A.1.2 하이퍼-V 가상화 지원
* A.1.3 윈도 리눅스용 하위 시스템(WSL) 기능 활성화

## A.2 WSL 설치
## A.3 도커 설치 및 구성
## A.4 소스 내려받아 빌드하기

## A.5 컨테이너 실습
* A.5.1 도커 컴포즈 실행
* A.5.2 스웨거 접속
* A.5.3 도커 컴포즈 종료 