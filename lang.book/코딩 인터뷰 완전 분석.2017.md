##
* 이 회사에서 일하고 싶은 이유
* 무엇에 흥미를 느끼는가
* 규모 확장성
* 어떻게 난관을 극복하는가; 가장 고치기 어려웠던 버그
* xxx와 의견이 맞지 않는 경우

## 이력서
* 이력서 길이
* 무엇을 성취했는지(개별)

## 행동 문제
* 가장 도전적이었던 것; 즐거웠던 것; 남들과 다르게 행동했던 것
* 실수 혹은 실패담; 본인의 단점
* 리더십; 팀원과의 갈등
* 질문: 롤 구성/비율; 사용 기술; 원하는 기술 경험/기회 가능성
* 프로젝트: 도전적 요소 존재, 중심 역할 여부, 기술 깊이 토론
* 구조적 답변: 유용한 정보 우선; 상황/행위/결과 접근법
* 자기 소개: 현재(최근) 직업/역할, 학교, 졸업 후, 업무 외, 마무리

## big-O
* 시간 복잡도
	* O(s): 선형적 증가; O(1): 상수 시간 소요; 선형식은 언젠가 상수를 뛰어넘음 
		* O(logN), O(NlogN), O(N), O(N^2), O(2^N), ... 
	* big-O: 시간의 상한: O(N^2), O(N^3), O(2^N), ... 보다 빠르다: 상한 
	* big-theta: 등가 혹은 하한: theta(N), theta(logN), theta(1), ... 보다 느리다: 하한 
	* big-omega: O(N) 이면서 theta(N)이면 omega(N): 딱 맞는 수행 시간 
	* 최선, 최악, 평균 
		* 퀵소트: 최선 O(N), 최악 O(N^2), 평균 O(NlogN) 
		* 최선은 논의 대상 아님, 다수의 경우 최악과 평균이 같음 
* 공간 복잡도 
	* 크기 n 배열에 O(n) 공간 필요; n*n 크기 2차원 배열에 O(n^2) 공간 필요

## 기술적 문제
* 핵심 자료구조/알고리즘/개념
    * 자료구조: 링크드 리스트, 트리/트라이/그래프, 스택&큐, 힙, 벡터/ArrayList, 해시테이블
    * 알고리즘: 너비 우선 탐색, 깊이 우선 탐색, 이진 탐색, 머지 소트, 퀵 소트
    * 개념: 비트 조작, 메모리(스택 vs 힙), 재귀, 다이나믹 프로그래밍, 빅오 시간&공간
* 듣기 => 예제 => 무식하게 풀기 => 최적화 => 검토 => 구현 => 테스트
    * 병목현상, 불필요한 작업, 중복되는 작업
    
## 자료 구조
* 배열과 문자열
    * 해시테이블: 키를 값에 대응(충돌 가능성); 연결 리스트와 해시 코드 함수; 혹은 균형 이진 탐색 트리
    * ArrayList와 가변 크기 배열; StringBuilder
* 연결리스트
* 스택과 큐
    * 스택: LIFO
* 트리와 그래프

## 개념과 알고리즘
* 객체지향설계
    * 접근법: 모호성 해소 => 핵심 객체 설계 => 관계 분석 => 행동 분석
* 시스템 설계: 단계별 접근: 문제 범위 한정 => 합리적 가정 => 중요 부분 그리기 => 핵심 문제점 찾기 => 해결 위해 다시 설계
* 시스템 설계 핵심 개념: 수평적(노드 개수 늘림) vs 수직적 규모 확장, 로드 밸런서, DB 역정규화 & NoSQL, DB 샤딩, 캐싱, 비동기식 처리 & 큐, 네트워크 성능, 맵리듀스

## 지식 기반 문제
