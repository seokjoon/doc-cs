## 1장 잘못된 구조의 문제 깨닫기
* 1.1 의미를 알 수 없는 이름
* 1.3 수많은 악마를 만들어 내는 데이터 클래스
	* 데이터 계산 로직이 분산된 경우


## 2장 설계 첫걸음
* 2.1 의도를 분명히 전달할 수 있는 이름 설계하기
* 2.2 목적별로 변수를 따로 만들어 사용하기
* 2.3 단순 나열이 아니라, 의미 있는 것을 모아 메서드로 만들기
* 2.4 관련된 데이터와 로직을 클래스로 모으기


## 3장 클래스 설계: 모든 것과 연결되는 설계 기반
* 3.1 클래스 단위로 잘 동작하도록 설계하기
	* 메서드와 인스턴스 변수를 함께 포함하는 클래스: 응집도 높음
* 3.2 성숙한 클래스로 성장시키는 설계 기법
	* 생성자로 확실해 값 전달, 생성자에서 유효성 검사(가드)
	* 계산도 데이터를 가진 쪽에서 구현: 응집도 높음
	* 인스턴스 변수를 불변(immutable)으로: final
		* 변경시 새 인스턴스로
* 3.4 프로그램 구조의 문제 해결에 도움을 주는 디자인 패턴
	* 완전 생성자, 값 객체


## 4장 불변 활용하기: 안정적으로 동작하게 만들기
* 4.1 재할당
	* 지역변수, 매개변수를 final
* 4.2 가변으로 인해 발생하는 의도하지 않은 영향
* 4.3 불변과 가변은 어떻게 다루어야 할까


## 5장 응집도: 흩어져 있는 것들
* 5.1 static 메서드 오용
	* static 메서드는 인스턴스 변수 사용 불가
* 5.2 초기화 로직 분산
	* 생성로직이 증가하면 팩토리 클래스 고려
* 5.3 범용 처리 클래스(Common/Util)
	* 횡단 관심사는 범용 코드가 적합
* 5.4 결과를 리턴하는 데 매개변수 사용하지 않기
	* 전달한 매개변수가 변경되는 상황: 출력 매개변수: 응집도 낮아짐
* 5.5 매개변수가 너무 많은 경우
	* 단일 메소드에서 많은 기능이 처리됨
	* 기본 자료형에 대한 집착
* 5.6 메서드 체인
	* 클래스 내부 깊은 요소에 접근
	* 응집도 높이기 위해서는 '묻지 말고 명령하기' 방식이 유용


## 6장 조건 분기: 미궁처럼 복잡한 분기 처리를 무너뜨리는 방법
* 6.1 조건 분기가 중첩되어 낮아지는 가독성
	* 조기 리턴, else 제거
* 6.2 switch 조건문 중복
	* 조건 분기 모으기
	* 인터페이스 활용
* 6.3 조건 분기 중복과 중첩
	* 정책 패턴으로 규칙을 구조화
* 6.4 자료형 확인에 조건 분기 사용하지 않기
* 6.5 인터페이스 사용 능력이 중급으로 올라가는 첫걸음
* 6.6 플래그 매개변수


## 7장 컬렉션: 중첩을 제거하는 구조화 테크닉
* 7.1 이미 존재하는 기능을 다시 구현하지 말기
	* for, if 중첩 조합 대신 anyMatch()
* 7.2 반복 처리 내부의 조건 분기 중첩
	* 조기 continue, 조기 break
* 7.3 응집도가 낮은 컬렉션 처리
	* 일급 컬렉션 패턴


## 8장 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조
* 8.1 결합도와 책무
	* 단일 책임 위반, 상속 관련 강결합, 슈퍼클래스 의존
	* 상속보다 컴포지션으로: 필요한 클래스를 private 인스턴스 변수로 사용
* 8.2 다양한 강한 결합 사례와 대처 방법
	* 거대 데이터 클래스
	* 트랜잭션 스크립트 패턴, god 클래스


## 9장 설계의 건전성을 해치는 여러 악마
* 9.1 데드 코드
* 9.2 YAGNI 원칙
* 9.3 매직 넘버
* 9.4 문자열 자료형에 대한 집착
* 9.5 전역 변수
* 9.6 null 문제
	* null을 리턴하지 않고 전달하지 않음
* 9.7 예외를 catch하고서 무시하는 코드
* 9.8 설계 질서를 파괴하는 메타 프로그래밍
* 9.9 기술 중심 패키징
	* 비즈니스 중심 패키징


## 10장 이름 설계: 구조를 파악할 수 있는 이름
* 10.1 악마를 불러들이는 이름
	* 거대 개념은 강결합, 악영항: 관심사 분리 필요
* 10.2 이름 설계하기 - 목적 중심 이름 설계
* 10.4 의미를 알 수 없는 이름
	* 기술 중심 명명, 로직 구조 명명, 놀람 최소화 원칙
* 10.5 구조에 악영향을 미치는 이름
	* 클래스를 거대하게 만드는 이름
	* 상황에 따라 의미가 다른 이름
* 10.6 이름을 봤을 때, 위치가 부자연스러운 클래스
	* 가급적 메서드 이름은 동사 하나로
* 10.7 이름 축약


## 11장 주석: 유지 보수와 변경의 정확성을 높이는 주석 작성 방법


## 12장 메서드(함수): 좋은 클래스에는 좋은 메서드가 있다
* 12.1 반드시 현재 클래스의 인스턴스 변수 사용하기
* 12.2 불변을 활용해서 예상할 수 있는 메서드 만들기
* 12.3 묻지 말고 명령하라
* 12.4 커맨드/쿼리 분리
	* CQS: command-query separation: 메소드는 커맨드 또는 쿼리 중 하나만 실행, 둘 다 실행하는 모디파이어는 회피할것
* 12.5 매개변수
* 12.6 리턴 값


## 13장 모델링: 클래스 설계의 토대
* 13.1 악마를 불러들이기 쉬운 User 클래스
	* 유스케이스 다이어그램
	* 목적별 모델링, 모델은 대상이 아니라 목적 달성의 수단
* 13.2 모델링으로 접근해야 하는 구조
* 13.3 안 좋은 모델의 문제점과 해결 방법
* 13.4 기능성을 좌우하는 모델링


## 14장 리팩터링: 기존의 코드를 성장시키는 기술
* 14.1 리팩터링의 흐름
* 14.2 단위 테스트로 리팩터링 중 실수 방지하기
* 14.3 불확실한 사양을 이해하기 위한 분석 방법
* 14.4 IDE의 리팩터링 기능
* 14.5 리팩터링 시 주의 사항


## 15장 설계의 의의와 설계를 대하는 방법
* 15.4 문제 해결하기
	* 소프트웨어 가치 메트릭: 비 가시 영역: 아키텍처, 기술부채
* 15.5 코드의 좋고 나쁨을 판단하는 지표
	* 메소드 10줄 이내, 클래스 100줄 이내
	* 순환 복잡도, 응집도, 결합도, 청크


## 16장 설계를 방해하는 개발 프로세스와의 싸움


## 17장 설계 기술을 계속해서 공부하려면
