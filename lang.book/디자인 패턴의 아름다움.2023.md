## CHAPTER 1 개요 1


## CHAPTER 2 객체지향 프로그래밍 패러다임 23
* 2.2 캡슐화, 추상화, 상속, 다형성이 등장한 이유 28
* 2.3 객체지향 분석, 객체지향 설계, 객체지향 프로그래밍을 수행하는 방법 40
	* 클래스간의 상호작용: 일반화, 실체화, 집합, 합성, 연관, 의존
* 2.4 객체지향 프로그래밍, 절차적 프로그래밍, 함수형 프로그래밍의 차이 55
* 2.5 객체지향 프로그래밍처럼 보이지만 실제로는 절차적 프로그래밍 70
  * 2.5.1 getter, setter 메서드 남용 70
  * 2.5.2 전역 변수와 전역 메서드의 남용 74
  * 2.5.3 데이터와 메서드 분리로 클래스 정의하기 77
  	* VO(view object: 컨트롤러계층), BO(business object: 서비스계층), entity(저장소계층): 빈약한 도메인 모델
* 2.6 빈약한 도메인 모델에 기반한 전통적인 개발 방식은 OOP를 위반하는가? 79
  * 2.6.1 빈약한 도메인 모델에 기반한 전통적인 개발 방식 80
  * 2.6.2 풍성한 도메인 모델에 기반한 DDD 개발 방식 82
  * 2.6.3 두 가지 개발 방식의 비교 83
  * 2.6.4 빈약한 도메인 모델에 기반한 전통적인 개발 방식이 널리 사용되는 이유 90
  * 2.6.5 풍성한 도메인 모델에 기반한 DDD 개발 방식의 응용 시나리오 91
  	* 비즈니스 논리의 위치: 서비스 or 도메인
  	* DB 의존도
* 2.7 추상 클래스와 인터페이스 93
* 2.8 인터페이스 기반 프로그래밍: 모든 클래스에 대해 인터페이스를 정의해야 할까? 102
* 2.9 상속보다 합성 109


## CHAPTER 3 설계 원칙 117
* 3.1 단일 책임 원칙 117
* 3.2 개방 폐쇄 원칙 123
  * 3.2.1 확장할 때는 개방, 수정할 때는 폐쇄 123
  * 3.2.3 확장할 때는 개방, 수정할 때는 폐쇄를 달성하는 방법 131
* 3.3 리스코프 치환 원칙 134
* 3.4 인터페이스 분리 원칙 139
* 3.5 의존 역전 원칙 149
* 3.6 KISS 원칙과 YAGNI 원칙 155
* 3.7 DRY 원칙 161
* 3.8 LoD 169
  * 3.8.1 높은 응집도와 낮은 결합도에 대한 생각 169


## CHAPTER 4 코딩 규칙 179
 * 4.1.4 명명은 정확하지만 추상적이어야 한다 181


## CHAPTER 5 리팩터링 기법 197
* 5.1 리팩터링의 네 가지 요소: 목적, 대상, 시기, 방법 197
* 5.2 단위 테스트 201
* 5.3 코드 테스트 용이성 210
* 5.4 디커플링 223
* 5.5 리팩터링 예제 227


## CHAPTER 6 생성 디자인 패턴 253
* 6.1 싱글턴 패턴 (1) 253
* 6.2 싱글턴 패턴 (2) 268
* 6.3 팩터리 패턴 (1) 273
* 6.4 팩터리 패턴 (2) 284
* 6.5 빌더 패턴 293
* 6.6 프로토타입 패턴 302


## CHAPTER 7 구조 디자인 패턴 313
* 7.1 프록시 패턴 313
* 7.2 데커레이터 패턴: Java IO 라이브러리의 기본 설계 사상 분석 320
* 7.3 어댑터 패턴 328
* 7.4 브리지 패턴 343
* 7.5 퍼사드 패턴 344
* 7.6 복합체 패턴 348
* 7.7 플라이웨이트 패턴 356


## CHAPTER 8 행동 디자인 패턴 371
* 8.1 옵서버 패턴 371
  * 8.1.5 비동기식 비차단 옵서버 패턴 377
* 8.2 템플릿 메서드 패턴 (1) 388
* 8.3 템플릿 메서드 패턴 (2) 396
* 8.4 전략 패턴 405
* 8.5 책임 연쇄 패턴 417
* 8.6 상태 패턴 439
* 8.7 반복자 패턴 (1) 451
* 8.8 반복자 패턴 (2) 464
* 8.9 비지터 패턴 470
* 8.10 메멘토 패턴 485
* 8.11 커맨드 패턴 490
* 8.12 인터프리터 패턴 494
* 8.13 중재자 패턴 502
