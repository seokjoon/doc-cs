## 1장 사용자 수에 따른 규모 확장성
* 단일 서버
* 데이터베이스
* 수직적 규모 확장 vs 수평적 규모 확장
	* 로드밸런서
	* 데이터베이스 다중화
* 캐시
* 콘텐츠 전송 네트워크(CDN)
* 무상태(stateless) 웹계층
	* 상태 정보 의존적 아키텍처
	* 무상태 아키텍처
* 데이터 센터
* 메시지 큐
* 로그, 메트릭, 자동화
* 데이터베이스의 규모 확장
* 백만 사용자, 그 이상
	* 웹 계층은 무상태, 모든 계층에 다중화 도입, 가능한 많은 데이터를 캐시, 여러 데이터 센터 지원, 정적 콘텐츠는 CDN, 데이터 계층은 샤딩을 통해 규모 확장, 각 계층은 독립적 서비스, 시스템을 지속 모니터링하고 자동화 도구 활용


## 2장 개략적인 규모 추정
* 2의 제곱수
* 응답지연 값
	* 메모리는 빠르고 디스크는 느림, 디스크 탐색은 가능한 회피, 단순한 압축 알고리즘 빠름, 데이터를 
* 가용성 수치들
	* 99.99%: 일당 8.64초
* 예제: 트위터 QPS와 저장소 요구량 추정


## 3장 시스템 설계 면접 공략법
	* 뉴스 피드: 피드 publishing, 피드 building
* 문제 이해 및 설계 범위 확정
* 개략적 설계안 제시 및 동의 구하기
* 상세 설계


## 4장 처리율 제한장치의 설계
* 문제 이해 및 설계 범위 확정
	* 요구사항: 제한을 설정, 낮은 응답시간, 적은 메모리 사용, 분산형 처리율 제한(여러 서버/프로세스가 공유), 예외 처리 피드백, 높은 결함 감내성
* 개략적 설계안 제시 및 동의 구하기
	* 처리율 제한 장치의 위치
	* 알고리즘: 토큰 버킷, 누출 버킷, 고정 윈도 카운터, 이동 윈도 로그, 이동 윈도 카운터
* 상세 설계
* 마무리


## 5장 안정해시 설계
* 해시 키 재배치(rehash) 문제
* 안정 해시
	* 해시 테이블 크기가 조정될 때 최소한의 키만 재배치하는 해시 기술
	* 해시 공간과 해시 링, 해시 서버, 해시 키, 서버 조회, 서버 추가, 서버 제거
	* 기본 구현법의 두 가지 문제, 가상 노드, 재배치할 키 결정


## 6장 키-값 저장소 설계
* 문제 이해 및 설계 범위 확정
	* 키-값 크기, 큰 데이터 수용, 높은 가용성, 높은 규모 확장성, 데이터 일관성 수준 조정 가능, 응답 지연시간 짧음
* 단일 서버 키-값 저장소
	* 키-값 쌍 전무를 메모리에 해시 테이블로 저장
* 분산 키-값 저장소
	* 분산 해키 테이블: 키-값 쌍을 여러 서버에 분산
	* CAP 정리: CAP를 동시에 만족하는 분산 시스템은 불가능, 셋 중 하나는 반드시 희생
		* 일관성(consistency): 어느 노드에 접속해도 같은 데이터 표시
		* 가용성(availability): 일부 노드에 장애가 발생해도 항상 응답 가능
		* 파티션 감내(partition tolerance): 파티션(두 노드 사이에 통신 장애 발생)이 생기더라도 시스템은 계속 동작
	* CP 시스템: 일관성, 파티션 감내를 지원, 가용성 희생
	* AP 시스템: 가용성과 파티션 감내를 지원, 데이터 일관성 희생
	* CA 시스템: 일관성과 가용성 지원, 파티션 감내를 희생
		* 네트워크 장애는 회피 불가하므로 분산시스템은 반드시 파티션 감내 가능해야 하므로
			* 실세계에서 CA 시스템은 존재하지 않음
	* 시스템 컴포넌트: 다이나모, 카산드라, 빅테이블 사례 참고
		* 데이터 파티션
			* 데이터를 여러 서버에 고르게 분산할 수 있는가
			* 노드가 추가되거나 삭제될 때 데이터 이동을 최소화할 수 있는가
			* 안정 해시
				* 규모 확장 자동화
				* 다양성(heterogeneity): 각 서버 용량에 맞게 가상 노드 개수 조정
		* 데이터 다중화(replication)
		* 일관성
			* 정족수 합의(quorum consensus) 프로토콜
			* 일관성 모델: 강한 일관성, 약한 일관성, 최종 일관성
		* 일관성 불일치 해소
			* 데이터 버저닝: 데이터 변경시 새 버전 생성, 각 버전 데이터는 변경 불가(immutable)
		* 장애 처리
			* 장애 처리, 장애 감지, 영구 장애 처리
		* 시스템 아키텍처 다이어그램
			* 클라이언트는 키-값 저장소가 제공하는 get, put api 와 통신
			* 중재자는 proxy 역할을 하는 노드
			* 노드는 안정 해시의 해시 링 위에 분포
			* 노드를 자동으로 추가/삭제할 수 있도록 시스템은 완전 분산
			* 데이터는 여러 노드에 다중화, SPOF(single point of failure)는 존재하지 않음
		* 쓰기 경로(write path)
			* 쓰기 요청이 커밋 로그에 기록
			* 데이터가 메모리 캐시에 기록
			* 메모리 캐시가 가득차거나 임계치에 도달하면 데이터를 디스크의 SSTable(sorted-string table) 에 기록
		* 읽기 경로(read path)
			* 데이터가 메모리에 있는지 검사
			* 없으면 블룸 필터를 검사하여 어떤 SSTable에 키가 보관되어 있는지 확인하여 데이터를 가져온 후 클라이언트에 반환
* 요약
	* 대규모 데이터 저장: 안정 해시를 사용해 서버들에 부하 분산
	* 읽기 연산 가용성: 데이터를 여러 데이터 센터에 다중화
	* 쓰기 연산 가용성: 버저닝 및 벡터 시계를 사용한 충돌 해소
	* 데이터 파티션: 안정 해시
	* 점진적 규모 확장성: 안정 해시
	* 다양성(heterogeneity): 안정 해시
	* 조절 가능한 데이터 일관성: 정족수 합의(quorum consensus)
	* 일시적 장애 처리: 느슨한 정족수 프로토콜(sloppy quorum)과 단서 후 임시 위탁(hinted handoff)
	* 영구적 장애 처리: 머클 트리(merkle tree)
	* 데이터 센터 장애 대응: 여러 데이터 센터에 걸친 데이터 다중화


## 7장 분산시스템을 위한 유일 ID 생성기 설계
* 문제 이해 및 설계 범위 확정
	* RDB auto increment: 여러 DB 서버를 사용해도 지연시간 문제
	* 유일, 숫자, 64비트, 시간 정렬, 초당 10,000개 생성
* 개략적 설계안 제시 및 동의 구하기
	* 다중 마스터 복제(multi-master replication)
		* DB의 auto_increment 기능 활용, 증가 폭이 1이 아니라 DB 서버 수
	* UUID
		* 충돌 가능성이 지극히 낮으므로 서버 간 조욜 없이 생성 가능
		* 단점: 128비트로 길고 시간순 정렬 불가, 숫자 아닌 값 포함됨
	* 티켓 서버
		* auto_increment를 단일 서버에서 발행: 티켓 서버가 SPOF
	* 트위터 스노플레이크 접근법
		* 요구사항 충족
		* 64비트 id 구조: sign 1 bit + 타임스탬프 41 bit + 데이터센터 id 5 bit + 서버 id 5 bit + 일련번호 12 bit
* 상세 설계
	* 기타: 시계 동기화, 길이 최적화, 고가용성


## 8장 URL 단축기 설계
* 문제 이해 및 설계 범위 확정
* 개략적 설계안 제시 및 동의 구하기
	* api 엔드포인트: post 요청
	* URL 리디렉션: get 요청
		* 응답: 301(moved)은 브라우저에서 캐시됨(서버 부하 감소), 302(found)는 분석/추적에 유리
		* 해시 테이블에 단축 url, 오리지널 url 저장
		* 실제 시스템에서는 RDB에 페어를 저장
* 상세 설계
	* 해시 함수 구현
		* 해시 후 충돌 해소: 원본 url 길이를 7글자까지 줄인 후(CRC32, MD5, SHA-1)
			* 길이 고정됨, 유일성 보장 id 생성기 불필요, 충돌 해소 전략 필요, id로 단축 url을 계산하지 않으므로 다음 생성 가능한 url 추정 불가
		* base-62 변환
			* 길이 가변적, 유일성 보장 id 생성기 필요, 충돌 불가, 다음 생성할 단축 url 유추 가능


## 9장 웹크롤러 설계
	* 사례: 검색 엔진 인덱싱, 웹 아카이빙, 웹 마이닝, 웹 모니터링
* 문제 이해 및 설계 범위 확정
	* 기본 알고리즘
		* url 집합 입력, 해당 url들이 가리키는 모든 페이지를 다운로드
		* 다운받은 페이지에서 url들을 추출
		* 반복
	* 고려: 규모 확장성(병행성), 안정성, 예절, 확장성
	* 규모 측정: QPS는 매달 10억개 페이지일 경우 초당 400페이지
* 개략적 설계안 제시 및 동의 구하기
	* 시작 url 집합
	* 미수집 url 저장소
	* html 다운로더
	* 도메인 이름 변환기
	* 콘텐츠 파서
	* 중복 콘텐츠 제거: 웹 페이지 해시 값 비교
	* 콘텐츠 저장소
	* url 추출기
	* url 필터
	* 이미 방문한 url: 블룸 필터나 해시 테이블
	* url 저장소
* 상세 설계
	* DFS(depth-first search) vs BFS(breath-first search)
		* 웹은 유향(directed) 그래프: 페이지는 node, 링크는 edge
		* 깊이 우선 탐색은 not good, 보통 너비 우선 탐색법
		* BFS는 FIFO 큐 사용
			* 문제
				* 페이지 내 상당수 링크는 동일 서버: 예의 없는 크롤링: DoS
				* 표준 BFS는 url 간 우선순위 없음
	* 미수집 url 저장소
		* 예의 갖춘 크롤링, url 우선순위와 신선도 구별
		* 동일 사이트에는 한번에 한 페이지만 요청: 호스트명과 작업 스레드 간 관계 유지
			* 큐 라우터: 같은 호스트의 url이 언제나 같은 큐로 가도록 보장
			* 매핑 테이블: 호스트명과 뮤 사이의 관계를 보관
			* FIFO 큐: 동일 호스트의 url은 동일 큐에 보관
			* 큐 선택기: 큐들을 순회하여 큐에서 url을 꺼내 지정된 작업 스레드에 전달
			* 작업 스레드: 순차적 처리, 작업들 간 지연시간 둘 수 있음
		* 우선순위
			* 페이지랭크, 트래픽 양, 갱신 핀도
			* 순위결정장치(prioritizer)
		* 전면 큐: 우선순위 결정 과정 처리
		* 후면 큐: 예의 작동 보증
		* 신선도: 재수집(recrawl)
			* 페이지 변경 이력 활용, 우선순위 높은 페이지는 재수집 빈도 높임
		* 지속성 저장장치
			* 병목지점 가능성 절충안: 대부분 url은 디스크에 두고 메모리 버퍼에 큐를 배치
	* html 다운로더
		* 로봇 프로토콜
		* 성능 최적화
			* 분산 크롤링: 여러 서버에 작업을 분산, 각 서버에서 여러 스레드 작동
			* 도메인 이름 변환 결과 캐시(주기적 갱신): dns resolver는 크롤러 성능 병목 중 하나
			* 지역성: 크롤링 대상과 지역적으로 가깝게
			* 짧은 타임아웃
	* 안정성
		* 안정 해시, 크롤링 상태 및 수집 데이터 저장(장애 발생시 복구), 예외 처리, 데이터 검증
	* 확장성
		* 새로운 모듈을 추가하여 새 형색의 콘텐츠 지원
	* 문제 콘텐츠 감지 및 회피 전략
		* 중복 콘텐츠, 거미 덫(spider trap, 크롤러를 무한 루프시킴)
		* 데이터 노이즈: 가치없음, 광고/스팸/스크립트
* 기타
	* 서버사이드 렌더링: 페이지를 파싱하기 전 적용
	* 스팸방지 컴포넌트 배치
	* 데이터베이스 다중화 및 샤딩
	* 수평적 규모 확장성: 서버가 상태정보를 유지하지 않도록(무상태 서버)
	* 가용성, 일관성, 안정성
	* 데이터 분석 솔루션


## 10장 알림 시스템 설계
* 문제 이해 및 설계 범위 확정
	* 푸시/SMS/이메일, soft real-time, mobile/pc
* 개략적 설계안 제시 및 동의 구하기
	* 유형별
		* ios: provider(device token, payload), APNS, 단말
		* android: provider, FCM, 단말
	* 전송 및 수신 절차
		* 컴포넌트 초안: 서비스 N개, 알림 시스템, 서드파티 서비스
			* SPOF, 규모 확장성, 성능 병목
		* 개선안: DB와 캐시를 알림 시스템 주 서버에서 분리, 수평적 규모 확장 가능하게, 메시지 큐를 이용해 강결합 제거
			* 서비스 N개: 알림을 보낼 서비스들
			* 알림 서버: 알림 전송 api, 알림 검증, DB 혹은 캐시 질의(알림 데이터 획득)
			* 알림 전송: 메시지 큐에 추가(병렬적)
				* 작업 서버(workers): 메시지 큐에서 알림을 추출하여 서드파티 서비스로 전달
		* 진행
			* api 호출, 알림서버로 알림 전달
			* 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 등 메타데이터를 캐시나 DB에서 획득
			* 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위한 큐에 추가
			* 작업 서버는 메시지 큐에서 알림 이벤트 꺼냄, 작업 서버는 알림을 서드파티 서비스로 전달
			* 서드 파티 서비스는 사용자 단말로 알림 전송
* 상세 설계
	* 안정성
		* 소실 방지(데이터 보관, 로그, 재시도): 지연/순서 변경은 허용
		* 중복 전송 감소를 위한 중복 탐지
	* 기타: 알림 템플릿, 알림 설정, 전송률 제한, 재시도 방법
	* 푸시 알림과 보안: api: appKey, appSecret
	* 큐 모니터링
	* 이벤트 추적: 알림 확인율, 클릭율, 전환율


## 11장 뉴스피드 시스템 설계
* 문제 이해 및 설계 범위 확정
	* 모바일/웹, 추가/열람, 순서(최신/순위), 친구 최대 수, 트래픽(DAU), 미디어(오디오/비디오) 포함 여부
* 개략적 설계안 제시 및 동의 구하기
	* 피드 발행(publishing)
		* 작성자, api(post), 로드밸런서, 웹서버, 포스팅 저장소(DB/캐시), 포스팅 전송 서비스(친구의 피드에 푸시), 알림 서비스
	* 피드 생성(building)
		* 열람자, api(get), 로드밸런서, 웹서버, 피드 서비스(캐시에서 피드를 획득), 피드 캐시(피드를 렌더링할때 필요한 피드 id를 보관)
* 상세 설계
	* 웹 서버: 클라이언트 통신, 인증(Authorization 헤더), 처리율 제한
	* 포스팅 전송(팬아웃(fanout): 새 포스팅을 친구들에게 전달) 서비스
		* 쓰기 시점 팬아웃(fanout-on-write, push 모델)
			* 실시간 갱신, pre-computed, 피드 읽기 시간 감소
			* 친구 많을 경우 갱신 소요 시간(hotkey), 비활성자 자원 낭비
		* 읽기 시점 팬아웃(fanout-on-read, pull 모델)
			* on-demand, 비활성자 효율, hotkey 이슈 없음
			* 피드 읽기 소요 시간 증가
	* 개선
		* 다수 사용자에게 push 모델, 친구가 많은 경우에 pull 모델
		* 안정 해시로 요청과 데이터를 고르게 분산
		* 팬아웃 서비스
			* 그래프 DB에서 친구 id 목록 획득
			* 사용자 정보 캐시에서 친구들 정보 획득: 설정으로 필터링(mute, private 등)
			* 친구 목록과 새 포스팅을 메시지 큐에 추가
			* 팬아웃 작업 서버가 메시지 큐에서 데이터를 꺼내어 피드 데이터를 피드 캐시에 추가
				* 피드 캐시: 포스팅 id, 사용자 id 페어를 보관하는 매핑 테이블
					* 새 포스팅 생성시마다 피드 캐시에 레코드 추가
					* 캐시 크기 제한
		* 피드 읽기
			* 피드 읽기 요청, 로드밸런서가 요청을 웹서버로 전달
			* 웹 서버는 피드 서비스 호출
			* 피드 서비스는 피드 캐시에서 포스팅 id 목록을 획득
			* 피드에 표시할 사용자 데이터(이름/사진/콘텐츠/이미지)를 사용자 캐시와 포스팅 캐시에서 가져와 완전한 피드 생성
			* 생성된 피드를 클라이언트에 반환(json), 클라이언트 렌더링
		* 캐시 구조: 캐시는 피드 시스템의 핵심 컴포넌트
			* 피드(피드 id 보관)
			* 콘텐츠: 인기, 일반
			* 소셜 그래프: 팔로어, 팔로잉
			* 행동: 좋아요, 답글, 기타
			* 횟수: 좋아요, 답글, 기타
* 기타
	* DB 규모 확장: 수직/수평, SQL/NoSQL, master/slave 다중화, replica 읽기 연산, 일관성(consistency) 모델, DB 사딩
	* 웹 계층 무상태 운영, 가능한 많은 ㄷ이터 캐시, 여러 데이터 센터 지원, 메시지 큐로 컴포넌트 결합도 낮추기, 핵심 메트릭(ex: 트래픽 높은 시간대의 QPS(queries per second)) 모니터링, 피드 새로고침시 지연시간


## 12장 채팅 시스템 설계
* 문제 이해 및 설계 범위 확정
* 개략적 설계안 제시 및 동의 구하기
* 상세 설계


## 13장 검색어 자동완성 시스템
* 문제 이해 및 설계 범위 확정
* 개략적 설계안 제시 및 동의 구하기
* 상세 설계


## 14장 유튜브 설계
* 문제 이해 및 설계 범위 확정
* 개략적 설계안 제시 및 동의 구하기
* 상세 설계


## 15장 구글드라이브 설계
* 문제 이해 및 설계 범위 확정
* 개략적 설계안 제시 및 동의 구하기
* 상세 설계


## 16장 배움은 계속된다 
* 실세계 시스템들