# 02: 도커 엔진
## 2.1 도커 이미지와 컨테이너
* 2.1.1 도커 이미지
* 2.1.2 도커 컨테이너
## 2.2 도커 컨테이너 다루기
* 2.2.1 컨테이너 생성
* 2.2.2 컨테이너 목록 확인
* 2.2.3 컨테이너 삭제
* 2.2.4 컨테이너를 외부에 노출
* 2.2.5 컨테이너 애플리케이션 구축
* 2.2.6 도커 볼륨
* 2.2.7 도커 네트워크
* 2.2.8 컨테이너 로깅
* 2.2.9 컨테이너 자원 할당 제한
## 2.3 도커 이미지
* 2.3.1 도커 이미지 생성
* 2.3.2 이미지 구조 이해
* 2.3.3 이미지 추출
* 2.3.4 이미지 배포
## 2.4 Dockerfile
* 2.4.1 이미지를 생성하는 방법
* 2.4.2 Dockerfile 작성
* 2.4.3 Dockerfile 빌드
* 2.4.4 기타 Dockerfile 명령어
* 2.4.5 Dockerfile로 빌드할 때 주의할 점
## 2.5 도커 데몬
* 2.5.1 도커의 구조
* 2.5.2 도커 데몬 실행
* 2.5.3 도커 데몬 설정
* 2.5.4 도커 데몬 모니터링
* 2.5.5 Remote API 라이브러리를 이용한 도커 사용


# 03: 도커 스웜
## 3.1 도커 스웜을 사용하는 이유
## 3.2 스웜 클래식과 도커 스웜 모드
## 3.3 스웜 모드
* 3.3.1 도커 스웜 모드의 구조
* 3.3.2 도커 스웜 모드 클러스터 구축
* 3.3.3 스웜 모드 서비스
* 3.3.4 도커 스웜 모드 노드 다루기


# 04: 도커 컴포즈
## 4.1 도커 컴포즈를 사용하는 이유
## 4.2 도커 컴포즈 설치
## 4.3 도커 컴포즈 사용
* 4.3.1 도커 컴포즈 기본 사용법
* 4.3.2 도커 컴포즈 활용


# 05: 쿠버네티스 설치
## 5.1 쿠버네티스 설치 환경의 종류
## 5.2 쿠버네티스 버전 선택
## 5.3 개발 용도의 쿠버네티스 설치
* 5.3.1 Docker for Mac / Windows에서 쿠버네티스 사용
* 5.3.2 Minikube로 쿠버네티스 설치
## 5.4 여러 서버로 구성된 쿠버네티스 클러스터 설치
* 5.4.1 kubeadm으로 쿠버네티스 설치
* 5.4.2 kops로 AWS에서 쿠버네티스 설치
* 5.4.3 구글 클라우드 플랫폼의 GKE로 쿠버네티스 사용하기


# 06: 쿠버네티스 시작하기
## 6.1 쿠버네티스를 시작하기 전에
## 6.2 포드(Pod) : 컨테이너를 다루는 기본 단위
* 6.2.1 포드 사용하기
* 6.2.2 포드 vs. 도커 컨테이너
* 6.2.3 완전한 애플리케이션으로서의 포드
## 6.3 레플리카셋(Replica Set) : 일정 개수의 포드를 유지하는 컨트롤러
* 6.3.1 레플리카셋을 사용하는 이유
* 6.3.2 레플리카셋 사용하기
* 6.3.3 레플리카셋의 동작 원리
* 6.3.4 레플리케이션 컨트롤러 vs. 레플리카셋
## 6.4 디플로이먼트(Deployment) : 레플리카셋, 포드의 배포를 관리
* 6.4.1 디플로이먼트 사용하기
* 6.4.2 디플로이먼트를 사용하는 이유
## 6.5 서비스(Service) : 포드를 연결하고 외부에 노출
* 6.5.1 서비스(Service)의 종류
* 6.5.2 ClusterIP 타입의 서비스 - 쿠버네티스 내부에서만 포드에 접근하기
* 6.5.3 NodePort 타입의 서비스 - 서비스를 이용해 포드를 외부에 노출하기
* 6.5.4 클라우드 플랫폼의 로드 밸런서와 연동하기 - LoadBalancer 타입의 서비스
* 6.5.5 트래픽의 분배를 결정하는 서비스 속성 : externalTrafficPolicy
* 6.5.6 요청을 외부로 리다이렉트하는 서비스 : ExternalName


# 07: 쿠버네티스 리소스의 관리와 설정
## 7.1 네임스페이스(Namespace) : 리소스를 논리적으로 구분하는 장벽
## 7.2 컨피그맵(Configmap), 시크릿(Secret) : 설정값을 포드에 전달
* 7.2.1 컨피그맵(Configmap)
* 7.2.2 시크릿(Secret)


# 08: 인그레스(Ingress)
## 8.1 인그레스를 사용하는 이유
## 8.2 인그레스의 구조
## 8.3 인그레스의 세부 기능 : annotation을 이용한 설정
## 8.4 Nginx 인그레스 컨트롤러에 SSL/TLS 보안 연결 적용
## 8.5 여러 개의 인그레스 컨트롤러 사용하기


# 09: 퍼시스턴트 볼륨(PV)과 퍼시스턴트 볼륨 클레임(PVC)
## 9.1 로컬 볼륨 : hostPath, emptyDir
* 9.1.1 워커 노드의 로컬 디렉터리를 볼륨으로 사용 : hostPath
* 9.1.2 포드 내의 컨테이너 간 임시 데이터 공유 : emptyDir
## 9.2 네트워크 볼륨
## 9.3 PV, PVC를 이용한 볼륨 관리
* 9.3.1 퍼시스턴트 볼륨과 퍼시스턴트 볼륨 클레임을 사용하는 이유
* 9.3.2 퍼시스턴트 볼륨과 퍼시스턴트 볼륨 클레임 사용하기
* 9.3.3 퍼시스턴트 볼륨을 선택하기 위한 조건 명시
* 9.3.4 퍼시스턴트 볼륨의 라이프사이클과 Reclaim Policy
* 9.3.5 StorageClass와 Dynamic Provisioning


# 10: 보안을 위한 인증과 인가 : ServiceAccount와 RBAC
## 10.1 쿠버네티스의 권한 인증 과정
## 10.2 서비스 어카운트와 롤(Role), 클러스터 롤(Cluster Role)
## 10.3 쿠버네티스 API 서버에 접근
* 10.3.1 서비스 어카운트의 시크릿을 이용해 쿠버네티스 API 서버에 접근
* 10.3.2 클러스터 내부에서 kubernetes 서비스를 통해 API 서버에 접근
* 10.3.3 쿠버네티스 SDK를 이용해 포드 내부에서 API 서버에 접근
## 10.4 서비스 어카운트에 이미지 레지스트리 접근을 위한 시크릿 설정
## 10.5 kubeconfig 파일에 서비스 어카운트 인증 정보 설정
## 10.6 유저(User)와 그룹(Group)의 개념
## 10.7 x509 인증서를 이용한 사용자 인증


# 11: 애플리케이션 배포를 위한 고급 설정
## 11.1 포드의 자원 사용량 제한
* 11.1.1 컨테이너와 포드의 자원 사용량 제한 : Limit
* 11.1.2 컨테이너와 포드의 자원 사용량 제한하기 : Request
* 11.1.3 CPU 자원 사용량의 제한 원리
* 11.1.4 QoS 클래스와 메모리 자원 사용량 제한 원리
* 11.1.5 ResourceQuota와 LimitRanger
* 11.1.6 ResourceQuota, LimitRanger의 원리 : Admission Controller
## 11.2 쿠버네티스 스케줄링
* 11.2.1 포드가 실제로 노드에 생성되기까지의 과정
* 11.2.2 포드가 생성될 노드를 선택하는 스케줄링 과정
* 11.2.3 NodeSelector와 Node Affinity, Pod Affinity
* 11.2.4 Taints와 Tolerations 사용하기
* 11.2.5 Cordon, Drain 및 PodDistributionBudget
* 11.2.6 커스텀 스케줄러 및 스케줄러 확장
## 11.3 쿠버네티스 애플리케이션 상태와 배포
* 11.3.1 디플로이먼트를 통해 롤링 업데이트
* 11.3.2 포드의 생애 주기(Lifecycle)


# 12: 커스텀 리소스와 컨트롤러
## 12.1 쿠버네티스 컨트롤러의 개념과 동작 방식
## 12.2 커스텀 리소스에 대한 개념
## 12.3 커스텀 리소스를 정의하기 위한 CRD(Custom Resource Definition)
## 12.4 커스텀 리소스와 컨트롤러


# 13: 포드를 사용하는 다른 오브젝트들
## 13.1 잡(Jobs)
## 13.2 데몬셋(DaemonSets)
## 13.3 스테이트풀셋(StatefulSets)


# 부록
## 부록A: 도커 데몬 시작 옵션 변경하기
## 부록B: 특정 버전의 도커 설치하기
## 부록C: gcloud 명령어 설치하기
## 부록D: AWS CLI 설치하기
